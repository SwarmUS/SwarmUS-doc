{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The SwarmUS Project A comprehensive, generic and easy-to-use swarm robotics platform. A heterogenous swarm of three robots (two Pioneer 2DX and one Turtlebot 3 Burger) using the SwarmUS platform SwarmUS is a project that helps creating swarms using existing robots. It is a generic development platform that empowers researchers and robotics enthousiasts with the ability to deploy some code easily to their robots. SwarmUS provides the basic infrastructure needed for robots to form a swarm : a decentralized communication stack and a localisation module that help robots locate one another without the need for a common reference. How SwarmUS works A HiveBoard The SwarmUS platform is built around a custom embedded computer called the HiveBoard . This board can be attached to any robot using an Ethernet or Micro-USB cable. The HiveBoard provides the three necessary features to form a robot swarm : A decentralized communication stack that allows the robots to exchange information and remote procedure calls. An interlocalisation module that allows robots to determine their relative position between one another. Each robot can therefore determine the distance and angle of another robot with respect to its own position. A coordination language that allows the user to program some behavioral logic for the swarm. The language used in the SwarmUS platform is Buzz . Forming a swarm using existing robots is as simple as plugging a HiveBoard in every robot, writing some coordination code, and interfacing this with each robot's program. The coordination code running on the HiveBoards will then control each individual robot in a coherent manner, in order to achieve some collective goals. The swarm can then be controlled by an Android application called HiveAR . This app allows the user to control the execution of the program, as well as to diagnose the state of each individual robots using a graphical user interface which uses augmented reality (AR). The app is a member of the swarm and uses its own HiveBoard to communicate with the other agents. When using SwarmUS, each agent needs to have its own HiveBoard. The swarm can be heterogenous, meaning that the robots can work together even if they don't have all the same capabilities. Architecture The SwarmUS platform is a decentralized system that comprises a number of different sub-systems. Let's dig in the architecture. This will help understanding how to use SwarmUS. A high-level view of the architecture of the SwarmUS platform At the center of the system lies the HiveBoard, an embedded computer designed specifically for SwarmUS. It boasts an STM-32 microcontroller (MCU) that manages the platform firmware, as well as a second MCU ( ESP-32 ) that handles the WiFi communication stack. The HiveBoard can host up to six auxiliary boards, called BeeBoards . These boards are simply antennas and Ultra-wideband (UWB) chips that are used to calculate the position of the other robots. A BeeBoard The HiveBoard is connected to a robot's embedded computer using an Ethernet cable. On the diagram shown above, the robot is assumed to run ROS, along with a few services. Note however that SwarmUS is completely ROS-agnostic and could be used on any software stack. HiveMind is the firmware that runs on the STM-32 MCU. This firmware manages three key features: the messaging service, the interlocalisation service, and the Buzz VM, which runs the user-code for the swarm's coordination. HiveConnect is the firmware that runs on the ESP-32 MCU. It provides the WiFi communication stack to the messaging service, and allows the configuration of various network topologies, including mesh. HiveMindBridge is a C++ library that provides an interface with the HiveBoard. It is meant to be used as a compatibility layer between the robot's existing program and the HiveBoard's services. Where to go from here This documentation provides some guides that will help setting up the different sub-systems that compose the SwarmUS platform. Users that simply want to try ou the platform will want to follow these User Guides . The user guides provide step-by-step instructions to help users implement a swarm solution using SwarmUS. Complete newcomers will want to start with the basic examples , which show how to use the core features of the SwarmUS platform. More thorough information about the inner workings of the various software components can also be found in the Reference section. For more information about the hardware developed for the SwarmUS project, visit the Hardware sections.","title":"Home"},{"location":"#the-swarmus-project","text":"A comprehensive, generic and easy-to-use swarm robotics platform. A heterogenous swarm of three robots (two Pioneer 2DX and one Turtlebot 3 Burger) using the SwarmUS platform SwarmUS is a project that helps creating swarms using existing robots. It is a generic development platform that empowers researchers and robotics enthousiasts with the ability to deploy some code easily to their robots. SwarmUS provides the basic infrastructure needed for robots to form a swarm : a decentralized communication stack and a localisation module that help robots locate one another without the need for a common reference.","title":"The SwarmUS Project"},{"location":"#how-swarmus-works","text":"A HiveBoard The SwarmUS platform is built around a custom embedded computer called the HiveBoard . This board can be attached to any robot using an Ethernet or Micro-USB cable. The HiveBoard provides the three necessary features to form a robot swarm : A decentralized communication stack that allows the robots to exchange information and remote procedure calls. An interlocalisation module that allows robots to determine their relative position between one another. Each robot can therefore determine the distance and angle of another robot with respect to its own position. A coordination language that allows the user to program some behavioral logic for the swarm. The language used in the SwarmUS platform is Buzz . Forming a swarm using existing robots is as simple as plugging a HiveBoard in every robot, writing some coordination code, and interfacing this with each robot's program. The coordination code running on the HiveBoards will then control each individual robot in a coherent manner, in order to achieve some collective goals. The swarm can then be controlled by an Android application called HiveAR . This app allows the user to control the execution of the program, as well as to diagnose the state of each individual robots using a graphical user interface which uses augmented reality (AR). The app is a member of the swarm and uses its own HiveBoard to communicate with the other agents. When using SwarmUS, each agent needs to have its own HiveBoard. The swarm can be heterogenous, meaning that the robots can work together even if they don't have all the same capabilities.","title":"How SwarmUS works"},{"location":"#architecture","text":"The SwarmUS platform is a decentralized system that comprises a number of different sub-systems. Let's dig in the architecture. This will help understanding how to use SwarmUS. A high-level view of the architecture of the SwarmUS platform At the center of the system lies the HiveBoard, an embedded computer designed specifically for SwarmUS. It boasts an STM-32 microcontroller (MCU) that manages the platform firmware, as well as a second MCU ( ESP-32 ) that handles the WiFi communication stack. The HiveBoard can host up to six auxiliary boards, called BeeBoards . These boards are simply antennas and Ultra-wideband (UWB) chips that are used to calculate the position of the other robots. A BeeBoard The HiveBoard is connected to a robot's embedded computer using an Ethernet cable. On the diagram shown above, the robot is assumed to run ROS, along with a few services. Note however that SwarmUS is completely ROS-agnostic and could be used on any software stack. HiveMind is the firmware that runs on the STM-32 MCU. This firmware manages three key features: the messaging service, the interlocalisation service, and the Buzz VM, which runs the user-code for the swarm's coordination. HiveConnect is the firmware that runs on the ESP-32 MCU. It provides the WiFi communication stack to the messaging service, and allows the configuration of various network topologies, including mesh. HiveMindBridge is a C++ library that provides an interface with the HiveBoard. It is meant to be used as a compatibility layer between the robot's existing program and the HiveBoard's services.","title":"Architecture"},{"location":"#where-to-go-from-here","text":"This documentation provides some guides that will help setting up the different sub-systems that compose the SwarmUS platform. Users that simply want to try ou the platform will want to follow these User Guides . The user guides provide step-by-step instructions to help users implement a swarm solution using SwarmUS. Complete newcomers will want to start with the basic examples , which show how to use the core features of the SwarmUS platform. More thorough information about the inner workings of the various software components can also be found in the Reference section. For more information about the hardware developed for the SwarmUS project, visit the Hardware sections.","title":"Where to go from here"},{"location":"sections/about/about/","text":"About The SwarmUS project was created by Engineering students from Universit\u00e9 de Sherbrooke, Qu\u00e9bec. The project was developed as a part of classes PMC660-760-860, spaning on three terms from the summer of 2020 to the autumn of 2021. The SwarmUS team was formed by 9 undergraduate students: Electrical Engineering Student Philippe Arsenault Philippe has worked on the electrical platform and more specifically on the BeeBoard, an active Ultra Wideband antenna. Computer Engineering Student Thierry Constantin Thierry has worked on the HiveAR Android application, both on the augmented reality and control interface aspects. Electrical Engineering Student Hubert Dub\u00e9 Hubert has worked on the electrical platform and the system localization scheme. Electrical Engineering Student Louis-Daniel Gaulin Louis-Daniel oversees the electrical division of the SwarmUS team. He worked on the HiveBoard, a low cost, high precision clock distribution board, also able to control up to six BeeBoards. Computer Engineering Student Xavier Groleau Xavier has worked on the BittyBuzz VM and the messaging system. Computer Engineering Student Samuel Laperri\u00e8re Samuel has worked on the HiveMindBridge library, as well as on this documentation website. Computer Engineering Student Gabriel Lessard Gabriel has worked on the network communications and other firmware-related development. Computer Engineering Student Charles Quesnel Charles has worked on the interlocalisation engine powered by the DW1000 UWB IC. Robotics Engineering Student \u00c9tienne Villemure \u00c9tienne led the design of the robots, has worked on the navigation system and the integration of the platform on the robots.","title":"About"},{"location":"sections/about/about/#about","text":"The SwarmUS project was created by Engineering students from Universit\u00e9 de Sherbrooke, Qu\u00e9bec. The project was developed as a part of classes PMC660-760-860, spaning on three terms from the summer of 2020 to the autumn of 2021. The SwarmUS team was formed by 9 undergraduate students: Electrical Engineering Student","title":"About"},{"location":"sections/hardware/","text":"Hardware Home The Hardware section presents the hardware that composes the SwarmUs platform: The HiveBoard . This is the main embedded computer that, when plugged into a robot, enables it with swarm capacities. The BeeBoard . These boards are Ultra-wideband (UWB) chip and antennas modules that allow the interlocalization to occur. There are meant to be plugged into a HiveBoard. Follow the link to learn more about each board specifically. The designs for both boards are hosted on GitHub .","title":"Hardware Home"},{"location":"sections/hardware/#hardware-home","text":"The Hardware section presents the hardware that composes the SwarmUs platform: The HiveBoard . This is the main embedded computer that, when plugged into a robot, enables it with swarm capacities. The BeeBoard . These boards are Ultra-wideband (UWB) chip and antennas modules that allow the interlocalization to occur. There are meant to be plugged into a HiveBoard. Follow the link to learn more about each board specifically. The designs for both boards are hosted on GitHub .","title":"Hardware Home"},{"location":"sections/hardware/BeeBoard/BeeBoard_V1.000/","text":"BeeBoard The Beeboard is an active Ultra Wideband (UWB) antenna designed to be used with the HiveBoard. It harbors a DW1000 IC under a faraday cage to receive the UWB signal. USB-C orientation detection The Beeboard has an automatic USB-C orientation detection system. Once the USB-C is plugged, it takes 500ms for the board to detect and arrange the switches to correctly route the signals. Error The V1.000 Beeboard is missing three pull-up resistors rendering the USB-C orientation detection unusable. Even if you are unsuccessful on the repair, the BeeBoard is still functionnal but the user will have to find the correct orientation. Connection with the HiveBoard V1.000 Error The designers made some mistakes in the routing of the signals between the HiveBoard V1.000 and the BeeBoard V1.000 and did not account the signal switching in the USB-C cable. A small board was designed to fix these issues called the Wings. It is available at the GitHub repo Important If using the HiveBoard V1.000 and BeeBoard V1.000, do not forget to have a Wings board for each BeeBoard for correct functionning. BeeBoard UI The BeeBoard has multiple user interface elements useful for the user and for debugging purposes (see image above). In purple are the single-ended test point, in red the 100 mil pins for SPI and the button and in orange triangles, the LEDs. In purple : 1.8V test point 3.3V test point 5V test point SEL, indicates the voltage of the selection. 3.3V logic. SEL#, always the inverse of SEL test point. CC2, indicates the voltage on the CC2 pin at the connector. CC1, indicates the voltage on the CC1 pin at the connector. CC1 and CC2 voltage are used to decide the USB-C orientation. Pulse, the pulse test point should have a pulse 500ms after the Beeboard is powered. The pulse is used to set the gates and switches selection. Ground hook. Reference all above test points with this one. A. CLK, the clock test point has a ground pad right beside it to reduce the current return path. B. Sync, the sync signal to synchronise the BeeBoards connected to one HiveBoard synchronised. In red : SPI 100 mils nCS SPI CLK MISO MOSI GND GND The button on the top right of the BeeBoard has the purpose of sending a pulse to reset the gates and the USB-C orientation detection flags. The orange triangles represent the LEDs present on the BeeBoard, D10 and D9 are user LEDs connected to the DW1000 and can be used for debugging purposes. D11 is connected to the EXTON output of the DW1000. The EXTON output is high when the DW100 is correctly powered, hence the LED should be always on. The LEDs D8 to D6 indicates the presence of the voltage 1.8V, 3.3V and 5V and should be on at all times. The top connector is a female SMA connector. It can be connected to any UWB antenna. Hint The antennas used in the project are the Ciholas antennas. V2.000 The BeeBoard has a 2.000 version (in the WORKING COPY folder) addressing the mistakes and bugs from V1.000. With the new DW3220 IC on the market, the entire HiveBoard-BeeBoard design should be revised.","title":"V1.000"},{"location":"sections/hardware/BeeBoard/BeeBoard_V1.000/#beeboard","text":"The Beeboard is an active Ultra Wideband (UWB) antenna designed to be used with the HiveBoard. It harbors a DW1000 IC under a faraday cage to receive the UWB signal.","title":"BeeBoard"},{"location":"sections/hardware/BeeBoard/BeeBoard_V1.000/#usb-c-orientation-detection","text":"The Beeboard has an automatic USB-C orientation detection system. Once the USB-C is plugged, it takes 500ms for the board to detect and arrange the switches to correctly route the signals. Error The V1.000 Beeboard is missing three pull-up resistors rendering the USB-C orientation detection unusable. Even if you are unsuccessful on the repair, the BeeBoard is still functionnal but the user will have to find the correct orientation.","title":"USB-C orientation detection"},{"location":"sections/hardware/BeeBoard/BeeBoard_V1.000/#connection-with-the-hiveboard-v1000","text":"Error The designers made some mistakes in the routing of the signals between the HiveBoard V1.000 and the BeeBoard V1.000 and did not account the signal switching in the USB-C cable. A small board was designed to fix these issues called the Wings. It is available at the GitHub repo Important If using the HiveBoard V1.000 and BeeBoard V1.000, do not forget to have a Wings board for each BeeBoard for correct functionning.","title":"Connection with the HiveBoard V1.000"},{"location":"sections/hardware/BeeBoard/BeeBoard_V1.000/#beeboard-ui","text":"The BeeBoard has multiple user interface elements useful for the user and for debugging purposes (see image above). In purple are the single-ended test point, in red the 100 mil pins for SPI and the button and in orange triangles, the LEDs. In purple : 1.8V test point 3.3V test point 5V test point SEL, indicates the voltage of the selection. 3.3V logic. SEL#, always the inverse of SEL test point. CC2, indicates the voltage on the CC2 pin at the connector. CC1, indicates the voltage on the CC1 pin at the connector. CC1 and CC2 voltage are used to decide the USB-C orientation. Pulse, the pulse test point should have a pulse 500ms after the Beeboard is powered. The pulse is used to set the gates and switches selection. Ground hook. Reference all above test points with this one. A. CLK, the clock test point has a ground pad right beside it to reduce the current return path. B. Sync, the sync signal to synchronise the BeeBoards connected to one HiveBoard synchronised. In red : SPI 100 mils nCS SPI CLK MISO MOSI GND GND The button on the top right of the BeeBoard has the purpose of sending a pulse to reset the gates and the USB-C orientation detection flags. The orange triangles represent the LEDs present on the BeeBoard, D10 and D9 are user LEDs connected to the DW1000 and can be used for debugging purposes. D11 is connected to the EXTON output of the DW1000. The EXTON output is high when the DW100 is correctly powered, hence the LED should be always on. The LEDs D8 to D6 indicates the presence of the voltage 1.8V, 3.3V and 5V and should be on at all times. The top connector is a female SMA connector. It can be connected to any UWB antenna. Hint The antennas used in the project are the Ciholas antennas.","title":"BeeBoard UI"},{"location":"sections/hardware/BeeBoard/BeeBoard_V1.000/#v2000","text":"The BeeBoard has a 2.000 version (in the WORKING COPY folder) addressing the mistakes and bugs from V1.000. With the new DW3220 IC on the market, the entire HiveBoard-BeeBoard design should be revised.","title":"V2.000"},{"location":"sections/hardware/HiveBoard/HiveBoard_V1.000/","text":"HiveBoard V1.000 The HiveBoard is a STM32H7 based development board. It harbors 6 USB-C channels to which up to 6 Beeboards can be connected. Important The USB-C at the top end of the HiveBoard are not actual USB-C. The connector was used because it houses five differential pairs which were required. Note The HiveBoard requires, on average, 1 A of current plus 0.4 A per BeeBoard connected. The absolute maximum calculated is 4.3A, with 6 BeeBoards sinking their maximum current. The HiveBoard is pluggable by three methods : The 5V jack 3A The screw terminal block (+ terminal on the right side) The Micro-USB The HiveBoard has the three basic protections of a complex circuit. It is protected in reverse polarity, over-voltage and overcurrent. The main switch located on the left bottom has three positions : Down: power is taken from the Micro-USB connector. Middle: Off state Up: power is taken from either 5V Jack or screw terminal block. Important If both 5V jack and screw terminal are connected, they will fight each other. Meaning that the one with lower voltage will receive current from the other one. It is recommended to use only one of these 2 methods at a time. Note Although the board can be powered by Micro-USB, not all the components on the board will be activated if powered by that method. Refer to the schematics and the Available UI for more info on the switches. System operation The top 6 USB-C are used to connect BeeBoards. The connectors are separated in pairs. Each pair (0A-1A/0B-1B/0C-1C) is supported by a single SPI channel from the STM32H7. Error If the V1.000 version of the HiveBoard is used, reworks will be necessary for correct operation of the system. For more details, see the schematics . The Ethernet connector is used to connect the HiveBoard to a host (be it a robot's embedded computer or any device that is to be swarm-enabled using the SwarmUS platform). The right side 100 mil connector is for exposing the unused I/Os of the STM32H7 in the case the user wants to supplement the HiveBoard with some other expansion card.","title":"V1.000"},{"location":"sections/hardware/HiveBoard/HiveBoard_V1.000/#hiveboard-v1000","text":"The HiveBoard is a STM32H7 based development board. It harbors 6 USB-C channels to which up to 6 Beeboards can be connected. Important The USB-C at the top end of the HiveBoard are not actual USB-C. The connector was used because it houses five differential pairs which were required. Note The HiveBoard requires, on average, 1 A of current plus 0.4 A per BeeBoard connected. The absolute maximum calculated is 4.3A, with 6 BeeBoards sinking their maximum current. The HiveBoard is pluggable by three methods : The 5V jack 3A The screw terminal block (+ terminal on the right side) The Micro-USB The HiveBoard has the three basic protections of a complex circuit. It is protected in reverse polarity, over-voltage and overcurrent. The main switch located on the left bottom has three positions : Down: power is taken from the Micro-USB connector. Middle: Off state Up: power is taken from either 5V Jack or screw terminal block. Important If both 5V jack and screw terminal are connected, they will fight each other. Meaning that the one with lower voltage will receive current from the other one. It is recommended to use only one of these 2 methods at a time. Note Although the board can be powered by Micro-USB, not all the components on the board will be activated if powered by that method. Refer to the schematics and the Available UI for more info on the switches.","title":"HiveBoard V1.000"},{"location":"sections/hardware/HiveBoard/HiveBoard_V1.000/#system-operation","text":"The top 6 USB-C are used to connect BeeBoards. The connectors are separated in pairs. Each pair (0A-1A/0B-1B/0C-1C) is supported by a single SPI channel from the STM32H7. Error If the V1.000 version of the HiveBoard is used, reworks will be necessary for correct operation of the system. For more details, see the schematics . The Ethernet connector is used to connect the HiveBoard to a host (be it a robot's embedded computer or any device that is to be swarm-enabled using the SwarmUS platform). The right side 100 mil connector is for exposing the unused I/Os of the STM32H7 in the case the user wants to supplement the HiveBoard with some other expansion card.","title":"System operation"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/","text":"Available UI - HiveBoard The HiveBoard has multiple indicators to help the user debug its configuration or its application. Purple dots/Test points Load switch Output Ground test point 3.3V debugger 3.3V channel Synchronisation signal. This test point has a ground pad right beside it for convenience 3.3V clock USB line towards the debugger from the hub. This is a differential test point. USB line towards the STM32H7 from the HUB. This is a differential test point. USB line towards the hub from the connector. This is a differential test point. A. 3.3V ESP32-WROOM B. 3.3V ethernet C. 5V entry D. 3.3V E. USB detection circuit F. 5V connector (Jack and terminal) G. 5V USB Green stars: RBG LED for ESP-32-WROOM RBG LED for STM32H7 Orange triangles, from top to bottom of the image: Channel enable (green LED) x6 Channel fault (red LED) x6 HeartBeat LED (green) MCU0 LED (green), user LED MCU1 LED (green), user LED MCU2 LED (green), user LED 3.3V LED (green) 5V LED (green) Red rectangles, from left to right: Buttons for FTDI, MCU and WROOM reset JTAG jumper, these jumpers shall stay in place if you want to use the on board debugger. Input/Output expander button Mezzanine connector, 100 mils 3.3V 5V GND GND SPI_CLK UART_Rx SPI_MISO UART_Tx SPI_MOSI GND GND ADC1_P I2C_SCL ADC1_N I2C_SDA GND Dark blue rectangles are DIP switches and are explained here Hardware These are the UI elements that are worth mentioning on a physical HiveBoard: ID on board Description LED RGB HiveMind comm interface WROOM RGB Networking Status LED (ESP-32) LED HB HiveMind heartbeat LED MCU_0 HiveMind and HiveConnect handshake LED MCU_1 HiveMind and Host handshake LED MCU_2 User LED LED 3.3v 3.3V is properly powered LED 5V 5V is properly powered 7 segment 1 BBVM status 7 segment 2 User 7 segment Power Switch The HiveBoard can be powered either via a 5V supply plugged into the black barrel connector or via the micro-USB plug. The power switch allows you to decide from where to take the power. The CON position instructs the boad to draw power from the barrel connector, while the USB position has the power drawn from the USB connector. Note Even if the power switch is on CON , the USB port still works and can be used to communicate with the board Important When powering the board by USB, no enough power is available to power all sub-circuits. The DIP Switches allow you to decide what to enable or disable. DIP Switches Because the board can draw up to 4 A and a USB connection is limited to 500 mA, DIP switches are available to disable sub-circuits that are not needed in order to fit in the power requirements. The switches only take effect when powered by USB. If powered from CON, all circuits are always enabled. Error The DIP switches are inverted in the first version of the HiveBoard. So when a switch is at the ON position, power is disabled to the given sub-circuit. Four different circuits are controlled from the switches: DEBUG: Controls the chip responsible for flashing/debugging the microcontrollers as well as create serial ports needed for logging WROOM: Controls the ESP32 responsible for Wi-Fi communication CHANNEL: Controls the channel hardware (this is very power hungry and probably should never be turned on while on USB) ETHERNET: Controls the Ethernet port and associated hardware In a normal usage, when plugged into a phone, all DIP switches other than WROOM should be on the ON position. This way, only the STM32 and the ESP32 are powered. Reset Buttons Three reset buttons are provided on the left hand side of the board. Each one performs a hardware reset of the specified chip. FTDI: Chip responsible for flashing/debugging the microcontrollers as well as create serial ports needed for logging MCU: The main STM32 microcontroller WROOM: The ESP32 responsible for Wi-Fi communication Error The WROOM reset button currently only works if the ESP32 logging serial port is opened (usually ttyUSB3). Channel EN / FLT LEDs Every BeeBoard channel has two LEDs associated with it. A red FLT and a green EN. Only one of the LEDs is on at any given time. A red LED means no power is currently being delivered to the channel, while the green LED means power is being delivered. Enablement of power to a given channel is done through the code depending on which channels have BeeBoards plugged in at bootup. If multiple BeeBoards are plugged in, when powering the board up, you should see each channel that has a BeeBoard plugged in turn from red to green. If one of the channels does not change, consider testing with a different BeeBoard or USB-C cable to find the culprit. Note Before a proper HiveMind firmware is flashed to the STM32, you may notice that some channels boot up as enabled even without a BeeBoard. This is because the line controlling the enablement of the channels is floating and must therefore be pulled down by the STM32 code (HiveMind). LED RGB - HiveMind Comm Interface Displays the status of the comm interface. Note that this means the comm interface is opened, not that the two devices communicate. They need to do a handshake after opening the interface. Thus a connection is fully established when the RGB is of color teal or blue and LED MCU_1 is on. If you plug the Ethernet or USB cable and the LED is not changing, make sure the TCP ports for Ethernet or the COM ports for USB match the ones that are open on the host. The RGB LED can take the following colours: Colour State White Booting Violet Unconnected Blue Connected via Ethernet Teal Connected via USB Red Error LED WROOM RGB - Networking Status LED (ESP-32) This RGB LED informs on the status of the Wi-Fi network. Refer to the Wi-Fi Configuration instructions for the configuration procedure. This RGB LED can take the following colours: Colour State Green Connected to an existing network Yellow Connecting Teal Access point available (is router) Red Not Connected LED HB - HiveMind Heartbeat The heartbeat of the HiveMind indicates that the firmware runs normally. In normal operation, this LED flashes at 1 Hz. If this LED is not flashing, HiveMind is probably in a hard fault state. This should not happen in theory, but things can always go wrong. Make sure everything is up to date and then you can consider raising an issue in the HiveMind repo if the issue wasn't already raised. LED MCU_0 - HiveMind and HiveConnect Handshake Shows if the HiveMind and the HiveConnect completed their handshake successfully. If the LED is not turned on after bootup, make sure everything is up to date (check versions of HiveMind and HiveConnect) and that the ESP power DIP switch is enabled. Error The DIP switches are inverted in the first version of the HiveBoard. So ON actually disables it. LED MCU_1 - HiveMind and Host Handshake Shows if the HiveMind and the host completed their handshake successfully. If the RGB LED is on, but not MCU_1 , make sure everything is up to date. This may be caused by an incompatible version of Pheromones (or Propolis that used the wrong Pheromones version). These two libraries are used by various elements of the stack (HiveMind, HiveMindBridge, HiveAR), and they must imperatively have matching versions. LED MCU_2 - User LED LED that can be set in the Buzz script via ui.set_led(x) . Use this to know the state of you application for easier debugging. You can get more information in the led blink user guide . The complete API documentation can be found here . LED 3.3V Is on if the 3.3V power supply is working properly. Check the power requirements if it's not on. LED 5V Is on if the 5V power supply is working properly. Check the power requirements if it's not on. 7 segment 1 - BBVM status The status of the BBVM, in which your Buzz code is run. If it's 0, the VM, is running fine. If it's a non zero value. The value represent the error code via an enumeration. The values of the enumeration can be found here . If you want more information about the error code meaning, you can check the BittyBuzz repo . 7 segment 2 - User segment A segment that can be set in the Buzz script via ui.set_hex(x) . Use this to have information about the state of your swarm application. You can get more information in the led blink user guide . The complete API documentation can be found here . ROS When simulating the usage of a HiveBoard on a computer, HiveMind will simulate the lower-level hardware stack using ROS (see HiveMind's readme ). This configuration replicates the interface of the HiveBoard via ROS logging system. Everytime something is written on the rosconsole, a string is prepended with the state of the HiveMind. The prepended string should be similar to: [HM: Id] [UI: rgb: V led: 000 hex: 01] The rgb is expressed via the first letter of its color. The led represents the MCU 0, 1 and 2 (handshake HiveConnect, handshake Host, user LED). The hex represents the 7 segments (VM state at the left and user 7 segment at the right).","title":"Available UI"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#available-ui-hiveboard","text":"The HiveBoard has multiple indicators to help the user debug its configuration or its application. Purple dots/Test points Load switch Output Ground test point 3.3V debugger 3.3V channel Synchronisation signal. This test point has a ground pad right beside it for convenience 3.3V clock USB line towards the debugger from the hub. This is a differential test point. USB line towards the STM32H7 from the HUB. This is a differential test point. USB line towards the hub from the connector. This is a differential test point. A. 3.3V ESP32-WROOM B. 3.3V ethernet C. 5V entry D. 3.3V E. USB detection circuit F. 5V connector (Jack and terminal) G. 5V USB Green stars: RBG LED for ESP-32-WROOM RBG LED for STM32H7 Orange triangles, from top to bottom of the image: Channel enable (green LED) x6 Channel fault (red LED) x6 HeartBeat LED (green) MCU0 LED (green), user LED MCU1 LED (green), user LED MCU2 LED (green), user LED 3.3V LED (green) 5V LED (green) Red rectangles, from left to right: Buttons for FTDI, MCU and WROOM reset JTAG jumper, these jumpers shall stay in place if you want to use the on board debugger. Input/Output expander button Mezzanine connector, 100 mils 3.3V 5V GND GND SPI_CLK UART_Rx SPI_MISO UART_Tx SPI_MOSI GND GND ADC1_P I2C_SCL ADC1_N I2C_SDA GND Dark blue rectangles are DIP switches and are explained here","title":"Available UI - HiveBoard"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#hardware","text":"These are the UI elements that are worth mentioning on a physical HiveBoard: ID on board Description LED RGB HiveMind comm interface WROOM RGB Networking Status LED (ESP-32) LED HB HiveMind heartbeat LED MCU_0 HiveMind and HiveConnect handshake LED MCU_1 HiveMind and Host handshake LED MCU_2 User LED LED 3.3v 3.3V is properly powered LED 5V 5V is properly powered 7 segment 1 BBVM status 7 segment 2 User 7 segment","title":"Hardware"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#power-switch","text":"The HiveBoard can be powered either via a 5V supply plugged into the black barrel connector or via the micro-USB plug. The power switch allows you to decide from where to take the power. The CON position instructs the boad to draw power from the barrel connector, while the USB position has the power drawn from the USB connector. Note Even if the power switch is on CON , the USB port still works and can be used to communicate with the board Important When powering the board by USB, no enough power is available to power all sub-circuits. The DIP Switches allow you to decide what to enable or disable.","title":"Power Switch"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#dip-switches","text":"Because the board can draw up to 4 A and a USB connection is limited to 500 mA, DIP switches are available to disable sub-circuits that are not needed in order to fit in the power requirements. The switches only take effect when powered by USB. If powered from CON, all circuits are always enabled. Error The DIP switches are inverted in the first version of the HiveBoard. So when a switch is at the ON position, power is disabled to the given sub-circuit. Four different circuits are controlled from the switches: DEBUG: Controls the chip responsible for flashing/debugging the microcontrollers as well as create serial ports needed for logging WROOM: Controls the ESP32 responsible for Wi-Fi communication CHANNEL: Controls the channel hardware (this is very power hungry and probably should never be turned on while on USB) ETHERNET: Controls the Ethernet port and associated hardware In a normal usage, when plugged into a phone, all DIP switches other than WROOM should be on the ON position. This way, only the STM32 and the ESP32 are powered.","title":"DIP Switches"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#reset-buttons","text":"Three reset buttons are provided on the left hand side of the board. Each one performs a hardware reset of the specified chip. FTDI: Chip responsible for flashing/debugging the microcontrollers as well as create serial ports needed for logging MCU: The main STM32 microcontroller WROOM: The ESP32 responsible for Wi-Fi communication Error The WROOM reset button currently only works if the ESP32 logging serial port is opened (usually ttyUSB3).","title":"Reset Buttons"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#channel-en-flt-leds","text":"Every BeeBoard channel has two LEDs associated with it. A red FLT and a green EN. Only one of the LEDs is on at any given time. A red LED means no power is currently being delivered to the channel, while the green LED means power is being delivered. Enablement of power to a given channel is done through the code depending on which channels have BeeBoards plugged in at bootup. If multiple BeeBoards are plugged in, when powering the board up, you should see each channel that has a BeeBoard plugged in turn from red to green. If one of the channels does not change, consider testing with a different BeeBoard or USB-C cable to find the culprit. Note Before a proper HiveMind firmware is flashed to the STM32, you may notice that some channels boot up as enabled even without a BeeBoard. This is because the line controlling the enablement of the channels is floating and must therefore be pulled down by the STM32 code (HiveMind).","title":"Channel EN / FLT LEDs"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#led-rgb-hivemind-comm-interface","text":"Displays the status of the comm interface. Note that this means the comm interface is opened, not that the two devices communicate. They need to do a handshake after opening the interface. Thus a connection is fully established when the RGB is of color teal or blue and LED MCU_1 is on. If you plug the Ethernet or USB cable and the LED is not changing, make sure the TCP ports for Ethernet or the COM ports for USB match the ones that are open on the host. The RGB LED can take the following colours: Colour State White Booting Violet Unconnected Blue Connected via Ethernet Teal Connected via USB Red Error","title":"LED RGB - HiveMind Comm Interface"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#led-wroom-rgb-networking-status-led-esp-32","text":"This RGB LED informs on the status of the Wi-Fi network. Refer to the Wi-Fi Configuration instructions for the configuration procedure. This RGB LED can take the following colours: Colour State Green Connected to an existing network Yellow Connecting Teal Access point available (is router) Red Not Connected","title":"LED WROOM RGB - Networking Status LED (ESP-32)"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#led-hb-hivemind-heartbeat","text":"The heartbeat of the HiveMind indicates that the firmware runs normally. In normal operation, this LED flashes at 1 Hz. If this LED is not flashing, HiveMind is probably in a hard fault state. This should not happen in theory, but things can always go wrong. Make sure everything is up to date and then you can consider raising an issue in the HiveMind repo if the issue wasn't already raised.","title":"LED HB - HiveMind Heartbeat"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#led-mcu_0-hivemind-and-hiveconnect-handshake","text":"Shows if the HiveMind and the HiveConnect completed their handshake successfully. If the LED is not turned on after bootup, make sure everything is up to date (check versions of HiveMind and HiveConnect) and that the ESP power DIP switch is enabled. Error The DIP switches are inverted in the first version of the HiveBoard. So ON actually disables it.","title":"LED MCU_0 - HiveMind and HiveConnect Handshake"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#led-mcu_1-hivemind-and-host-handshake","text":"Shows if the HiveMind and the host completed their handshake successfully. If the RGB LED is on, but not MCU_1 , make sure everything is up to date. This may be caused by an incompatible version of Pheromones (or Propolis that used the wrong Pheromones version). These two libraries are used by various elements of the stack (HiveMind, HiveMindBridge, HiveAR), and they must imperatively have matching versions.","title":"LED MCU_1 - HiveMind and Host Handshake"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#led-mcu_2-user-led","text":"LED that can be set in the Buzz script via ui.set_led(x) . Use this to know the state of you application for easier debugging. You can get more information in the led blink user guide . The complete API documentation can be found here .","title":"LED MCU_2 - User LED"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#led-33v","text":"Is on if the 3.3V power supply is working properly. Check the power requirements if it's not on.","title":"LED 3.3V"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#led-5v","text":"Is on if the 5V power supply is working properly. Check the power requirements if it's not on.","title":"LED 5V"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#7-segment-1-bbvm-status","text":"The status of the BBVM, in which your Buzz code is run. If it's 0, the VM, is running fine. If it's a non zero value. The value represent the error code via an enumeration. The values of the enumeration can be found here . If you want more information about the error code meaning, you can check the BittyBuzz repo .","title":"7 segment 1 - BBVM status"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#7-segment-2-user-segment","text":"A segment that can be set in the Buzz script via ui.set_hex(x) . Use this to have information about the state of your swarm application. You can get more information in the led blink user guide . The complete API documentation can be found here .","title":"7 segment 2 - User segment"},{"location":"sections/hardware/HiveBoard/hiveboard-ui/#ros","text":"When simulating the usage of a HiveBoard on a computer, HiveMind will simulate the lower-level hardware stack using ROS (see HiveMind's readme ). This configuration replicates the interface of the HiveBoard via ROS logging system. Everytime something is written on the rosconsole, a string is prepended with the state of the HiveMind. The prepended string should be similar to: [HM: Id] [UI: rgb: V led: 000 hex: 01] The rgb is expressed via the first letter of its color. The led represents the MCU 0, 1 and 2 (handshake HiveConnect, handshake Host, user LED). The hex represents the 7 segments (VM state at the left and user 7 segment at the right).","title":"ROS"},{"location":"sections/reference/","text":"Reference Home The Reference section contains precise information on various elements of the SwarmUS project's software stack. This section is meant to be used as a handbook for quick reference. Tip Users looking for step-by-step tutorials will want to refer to the User Guides section.","title":"Reference Home"},{"location":"sections/reference/#reference-home","text":"The Reference section contains precise information on various elements of the SwarmUS project's software stack. This section is meant to be used as a handbook for quick reference. Tip Users looking for step-by-step tutorials will want to refer to the User Guides section.","title":"Reference Home"},{"location":"sections/reference/architecture/","text":"The following figure shows a high-level view of the SwarmUS platform. In this case, a HiveBoard is plugged into a robot's embedded computer running ROS. Note however that HiveMind, the HiveBoard's firmware, can be interfaced with devices that do not run ROS. The HiveMindBridge library is a generic C++ library that will help interfacing any environment with a HiveBoard.","title":"Architecture of the System"},{"location":"sections/reference/Buzz/","text":"BittyBuzz virtual machine Buzz is a programming language made by MISTLAB for a swarm made of heterogeneous robots. Buzz code is compiled to byte code, which then runs on the Buzz Virtual Machine (BVM) which executes the bytecode. All robots in the swarm will then run the same byte code. Buzz provides multiple ways to manage the swarm of robots. You can learn more about Buzz here . The language reference is hosted here . Since the BVM was designed to run on Linux, another implementation was necessary to run on an MCU. A smaller and lighter virtual machine. This project is called BittyBuzz and it provides the BittyBuzz Virtual Machine (BBVM). The BittyBuzz virtual machine has some limitations. Here are the most important: Floating points are actually on 16 bits. See here Some mathematical operations are disabled, like raising a number by a decimal point. Strings are actually simply string id. This removes the need to store the string itself in the MCU This prevents all string manipulation or dynamic creation of strings. The swarmlist broadcast is not available on the BBZVM for now. Thus, neighbors.kin() , neighbors.nonkin() and swarm.others() are not available In this implementation, if you use HiveConnect to send messages in the swarm, the neighbors broadcast message will have a different range than the actual neighbor list. So it's possible to broadcast a message to a neighbor that is not in your neighbor when a foreach, map or reduce is applied (i.e. broadcast message have more range than the current neighbors). Strings On compilation, the strings in the script are stored in the program data. This allows to log with actual strings and call remote functions by name instead of only having the ID and registering function by its name. Dynamic string manipulation is impossible . Note that strings in the BBVM are more than just characters between \"\". All global variable names (namespace, constant, etc) are also stored with their associated strings. Since strings use memory on the MCU, you can disable the storing of the string. To do so, you can provide a BST file with the name of the strings to disable. You can add your BST files to the USER_BUZZ_INCLUDE_DIRS in this file . You can get an example of a BST file for the provided functions here . Also note that symbols reserved by the VM don't have a string representation, you can see them here . If you see UNKNOWN STRID: XX in the logs, where XX is a string ID, those strings are declared in a BST file (internal or user defined). You can see their values in the HiveMind build directory in src/bittybuzz/main_bytecode.h , in this file you can see the internal id of every strings. Available APIs in Buzz Scripts User-defined Buzz scripts can use some APIs to interact with some parts of the SwarmUS platform. This page regroups all these APIs and provides some links to their respective documentation. BittyBuzzUIFunctions : Interacting with the HiveBoard's UI Link to the documentation . This API provides some functions that can be used to interact with some UI elements on the HiveBoard. Users have access to one LED and one seven-segment display: BittyBuzzMathFunctions : Useful Math Tools Link to the documentation This API provides some math functions to be used in Buzz scripts. BittyBuzzUserFunctions : Managing User Functions Link to the documentation This API provides the necessary tools to register and call some custom functions. Compilation configuration You may need to edit the Bittybuzz config if you need more/less stack or heap memory in the BBVM. Check the available options here . The ones you may need are BBZHEAP_SIZE , BBZSTACK_SIZE and BBZ_CLOSURE_REGISTER_LENGTH . The closure register is used to register the Buzz functions in the script, so you may need to edit this value if you have a lot of registered functions. Tips Log as much as possible. While it may take some space on the MCU flash caused by the added strings representation, you should still log a lot. The language has no type check at the compilation and when a error occurs (i.e. calling a member on a nil value) there is no line number on the occurence since it was made to run on an MCU. Double check your variable names and types when writing code. In Buzz if a value was assigned, it's null, so it's perfectly valid for the compiler to pass a variable with a typo in it, which will have a nil value. Thus let fizz; function(fiz); would compile, but not have the desired outcome since the typo fiz is nil . Don't log on every step. The step function is called every 100ms (may change to 10ms). Logging everytime would pollute your logs, making it impossible to read anything. Use sleep as little as possible. While a sleep function is available, you shouldn't use it unless you understand the implications. Between every step function call, some processing is done. Mainly receive the messages from other swarm agent and send the message created during the execution to other swarm agents. If you sleep for too long, a queue may fill up and you will loose some messages. You should use the provided executor if you want to execute slower than the step.","title":"Buzz"},{"location":"sections/reference/Buzz/#bittybuzz-virtual-machine","text":"Buzz is a programming language made by MISTLAB for a swarm made of heterogeneous robots. Buzz code is compiled to byte code, which then runs on the Buzz Virtual Machine (BVM) which executes the bytecode. All robots in the swarm will then run the same byte code. Buzz provides multiple ways to manage the swarm of robots. You can learn more about Buzz here . The language reference is hosted here . Since the BVM was designed to run on Linux, another implementation was necessary to run on an MCU. A smaller and lighter virtual machine. This project is called BittyBuzz and it provides the BittyBuzz Virtual Machine (BBVM). The BittyBuzz virtual machine has some limitations. Here are the most important: Floating points are actually on 16 bits. See here Some mathematical operations are disabled, like raising a number by a decimal point. Strings are actually simply string id. This removes the need to store the string itself in the MCU This prevents all string manipulation or dynamic creation of strings. The swarmlist broadcast is not available on the BBZVM for now. Thus, neighbors.kin() , neighbors.nonkin() and swarm.others() are not available In this implementation, if you use HiveConnect to send messages in the swarm, the neighbors broadcast message will have a different range than the actual neighbor list. So it's possible to broadcast a message to a neighbor that is not in your neighbor when a foreach, map or reduce is applied (i.e. broadcast message have more range than the current neighbors).","title":"BittyBuzz virtual machine"},{"location":"sections/reference/Buzz/#strings","text":"On compilation, the strings in the script are stored in the program data. This allows to log with actual strings and call remote functions by name instead of only having the ID and registering function by its name. Dynamic string manipulation is impossible . Note that strings in the BBVM are more than just characters between \"\". All global variable names (namespace, constant, etc) are also stored with their associated strings. Since strings use memory on the MCU, you can disable the storing of the string. To do so, you can provide a BST file with the name of the strings to disable. You can add your BST files to the USER_BUZZ_INCLUDE_DIRS in this file . You can get an example of a BST file for the provided functions here . Also note that symbols reserved by the VM don't have a string representation, you can see them here . If you see UNKNOWN STRID: XX in the logs, where XX is a string ID, those strings are declared in a BST file (internal or user defined). You can see their values in the HiveMind build directory in src/bittybuzz/main_bytecode.h , in this file you can see the internal id of every strings.","title":"Strings"},{"location":"sections/reference/Buzz/#available-apis-in-buzz-scripts","text":"User-defined Buzz scripts can use some APIs to interact with some parts of the SwarmUS platform. This page regroups all these APIs and provides some links to their respective documentation.","title":"Available APIs in Buzz Scripts"},{"location":"sections/reference/Buzz/#bittybuzzuifunctions-interacting-with-the-hiveboards-ui","text":"Link to the documentation . This API provides some functions that can be used to interact with some UI elements on the HiveBoard. Users have access to one LED and one seven-segment display:","title":"BittyBuzzUIFunctions: Interacting with the HiveBoard's UI"},{"location":"sections/reference/Buzz/#bittybuzzmathfunctions-useful-math-tools","text":"Link to the documentation This API provides some math functions to be used in Buzz scripts.","title":"BittyBuzzMathFunctions: Useful Math Tools"},{"location":"sections/reference/Buzz/#bittybuzzuserfunctions-managing-user-functions","text":"Link to the documentation This API provides the necessary tools to register and call some custom functions.","title":"BittyBuzzUserFunctions: Managing User Functions"},{"location":"sections/reference/Buzz/#compilation-configuration","text":"You may need to edit the Bittybuzz config if you need more/less stack or heap memory in the BBVM. Check the available options here . The ones you may need are BBZHEAP_SIZE , BBZSTACK_SIZE and BBZ_CLOSURE_REGISTER_LENGTH . The closure register is used to register the Buzz functions in the script, so you may need to edit this value if you have a lot of registered functions.","title":"Compilation configuration"},{"location":"sections/reference/Buzz/#tips","text":"Log as much as possible. While it may take some space on the MCU flash caused by the added strings representation, you should still log a lot. The language has no type check at the compilation and when a error occurs (i.e. calling a member on a nil value) there is no line number on the occurence since it was made to run on an MCU. Double check your variable names and types when writing code. In Buzz if a value was assigned, it's null, so it's perfectly valid for the compiler to pass a variable with a typo in it, which will have a nil value. Thus let fizz; function(fiz); would compile, but not have the desired outcome since the typo fiz is nil . Don't log on every step. The step function is called every 100ms (may change to 10ms). Logging everytime would pollute your logs, making it impossible to read anything. Use sleep as little as possible. While a sleep function is available, you shouldn't use it unless you understand the implications. Between every step function call, some processing is done. Mainly receive the messages from other swarm agent and send the message created during the execution to other swarm agents. If you sleep for too long, a queue may fill up and you will loose some messages. You should use the provided executor if you want to execute slower than the step.","title":"Tips"},{"location":"sections/reference/Development/clion-setup/getting_started/","text":"To help future developers to join the project, this page shares how the embedded SwarmUS team set up its development environment. IDE Info This setup is not the only one that could be used and you can use your favourite tools. Since the embedded project is written in C and C++, the SwarmUS team decided to use the CLion IDE in Linux. Furthermore, this IDE has a plug-in for the OpenOCD debugger used in the project and has a lot of support for STM32 and Xtensa MCUs that can be found on the HiveBoard . So the first step of this guide will be to download this IDE. Attention The CLion IDE is inherently not free. However, there is a free version for students. Install repositories and dependencies The embedded parts of the SwarmUS project include the HiveMind software that runs on a STM32H7 and the HiveConnect that runs on an ESP-32. Before configuring the IDE, clone both of the repositories and install and set up all the required packages as described in HiveMind's readme and HiveConnect's readme . Make sure that you can build the two repositories before moving on to building the repositories in CLion. Once done, the next step is to configure CLion for the repository you want to work on: HiveMind or HiveConnect . Since a part of debugging is done via the serial port of the MCUs, an additional section is given to set up the logging of those channels in CLion","title":"Getting Started"},{"location":"sections/reference/Development/clion-setup/getting_started/#ide","text":"Info This setup is not the only one that could be used and you can use your favourite tools. Since the embedded project is written in C and C++, the SwarmUS team decided to use the CLion IDE in Linux. Furthermore, this IDE has a plug-in for the OpenOCD debugger used in the project and has a lot of support for STM32 and Xtensa MCUs that can be found on the HiveBoard . So the first step of this guide will be to download this IDE. Attention The CLion IDE is inherently not free. However, there is a free version for students.","title":"IDE"},{"location":"sections/reference/Development/clion-setup/getting_started/#install-repositories-and-dependencies","text":"The embedded parts of the SwarmUS project include the HiveMind software that runs on a STM32H7 and the HiveConnect that runs on an ESP-32. Before configuring the IDE, clone both of the repositories and install and set up all the required packages as described in HiveMind's readme and HiveConnect's readme . Make sure that you can build the two repositories before moving on to building the repositories in CLion. Once done, the next step is to configure CLion for the repository you want to work on: HiveMind or HiveConnect . Since a part of debugging is done via the serial port of the MCUs, an additional section is given to set up the logging of those channels in CLion","title":"Install repositories and dependencies"},{"location":"sections/reference/Development/clion-setup/hive_connect_setup/","text":"Before starting, make sure that you followed all the setup instructions of the HiveConnect's readme . Especially take note of the path where you downloaded the esp-idf repository. Building the project Open CLion Open the HiveConnect folder. Go in \"File->Open\", found the path to the root of the HiveConnect repository and click \"Open\". After that step, you should see the project directory on the right of the screen. Configure the toolchain. This step selects the build tool and compiler for the CMake profile. In the case of the HiveConnect project, it also sets important environment variables used for the building step. Go to \"File->Settings\". On the right menu go to \"Build, Execution, Deployment->Toolchains\". Create a new Toolchain, click on \"Add environment -> From file\" and set all the fields as follows: For the environment file, enter <path_to_esp-idf_directory>/esp-idf/export.sh Configure the Cmake profile. Go to \"File->Settings\". This step sets the build type and selects the toolchain file to build for the ESP32. On the right menu go to \"Build, Execution, Deployment->CMake\". Set all the fields as follow: You can copy the \"Cmake options\" line: -DCMAKE_TOOLCHAIN_FILE=cmake/esp-idf/toolchain-esp32.cmake Build the project. In the right corner, in the target drop-down menu (see image below) select the target named \"app\". To build the project, just click on the green hammer next to the drop-down menu. You can follow the building process in the \"Message\" tab console. This step will generate the hive_connect.elf and hive_connect.bin files that could both be used to flash the MCU. Important Don't start the build if the CMake has not finished its job. You can follow the progress of the CMake job in the \"CMake\" console tab at the bottom of the IDE. You can also follow the progress of the building process in the \"Messages\" tab. Flashing Now the project can be built, the compiled code in the hive_connect.elf can be flashed on the ESP32 MCU. However, compared to the HiveMind project, the same target can't be used to just build, flash and debug. You will need to switch between targets to perform those operations. However, the build action is automatically done before flashing and debugging. Go in the target drop-down menu where you selected the target \"hive_connect_flash\". Flash the board. Once the CLion is ready and the board is connected and powered, it's possible to flash the firmware. Click on the green hammer next to the selected target. A console should be put in evidence showing the progress of the flashing process. Warning The \"hive_connect_flash\" target flashes the board with the build (\"hammer\") icon not the play icon like the \"flash\" target of the HiveMind. Debugging Compared to the HiveMind firmware, the HiveConnect firmware can't be debugged directly by the OpenOCD target. This is mainly because the OpenOCD target flashes at the first address in memory of the flash and it would overwrite the bootloader present in the ESP32. Therefore, we need to flash the esp with OpenOCD with a new script and create a separate debug target to attach to the debug session. Open the target drop-down list and click on \"Edit configurations\". Add a command to flash the board with OpenOCD. First, click on the \"+\" to add a new target. Add a \"Shell Script\" target type. Fill the fields as shown below. First you will need to select \"Script text\". For the script text write ~/.espressif/tools/openocd-esp32/v0.10.0-esp32-20200709/openocd-esp32/bin/openocd -s share/openocd/scripts -f <path_to_hive connect_directory>/HiveConnect/tools/openocd/ft4232.cfg -c \"program_esp <path_to_hive connect_directory>/HiveConnect/cmake-build-debug/hive_connect.bin 0x10000\" . Also, make check sure that the option \"Execute in terminal\" is unchecked. Open the target drop-down list and click on \"Edit configurations\". Add the debug target. First, click on the \"+\" to add a new target. Add a \"Remote Debug\" target type. Fill the fields as shown below. For the debugger, if you installed all the required packages beforehand, you should be able to find the debugger at the path ~/.espressif/tools/xtensa-esp32-elf/esp-2020r3-8.4.0/xtensa-esp32-elf/bin/xtensa-esp32-elf-gdb For the target remote args: tcp:localhost:3333 For the symbol file, select the .elf generated by the build process <path_to_hive_connect_directory>/HiveConnect/cmake-build-debug/hive_connect.elf Connect and power the boards. Select the \"pre_debug_flash\" target and click on the \"play\" icon next to it. This should flash the board with OpenOCD and starts the debugging server on the MCU. A console should open to show the progress of this process. Select the \"esp_debug_gdb\" target in the target drop-down list. To start a debug session, click on the green bug icon on the right of the drop-down list. The \"Debug\" console should open and show the status of debug process by connecting to the 3333 port of the debugging session. From that point, you can use the debugger with breakpoints in your code like any debugger in an IDE. Refer to the \"Debugging\" section of the HiveMind setup to understand the debugging interface. Info Compared to the HiveMind debugging session, the debugging process is separated into two processes in parallel: The debug server launched on the MCU and the debug session launched in CLion attached to the debug server. These processes can be monitored in the \"Run\" and \"debug\" tabs separately. They can also be stopped separately, but most of the time, you will want to close both since there is no reason to keep only one running without the other.","title":"HiveConnect CLion setup"},{"location":"sections/reference/Development/clion-setup/hive_connect_setup/#building-the-project","text":"Open CLion Open the HiveConnect folder. Go in \"File->Open\", found the path to the root of the HiveConnect repository and click \"Open\". After that step, you should see the project directory on the right of the screen. Configure the toolchain. This step selects the build tool and compiler for the CMake profile. In the case of the HiveConnect project, it also sets important environment variables used for the building step. Go to \"File->Settings\". On the right menu go to \"Build, Execution, Deployment->Toolchains\". Create a new Toolchain, click on \"Add environment -> From file\" and set all the fields as follows: For the environment file, enter <path_to_esp-idf_directory>/esp-idf/export.sh Configure the Cmake profile. Go to \"File->Settings\". This step sets the build type and selects the toolchain file to build for the ESP32. On the right menu go to \"Build, Execution, Deployment->CMake\". Set all the fields as follow: You can copy the \"Cmake options\" line: -DCMAKE_TOOLCHAIN_FILE=cmake/esp-idf/toolchain-esp32.cmake Build the project. In the right corner, in the target drop-down menu (see image below) select the target named \"app\". To build the project, just click on the green hammer next to the drop-down menu. You can follow the building process in the \"Message\" tab console. This step will generate the hive_connect.elf and hive_connect.bin files that could both be used to flash the MCU. Important Don't start the build if the CMake has not finished its job. You can follow the progress of the CMake job in the \"CMake\" console tab at the bottom of the IDE. You can also follow the progress of the building process in the \"Messages\" tab.","title":"Building the project"},{"location":"sections/reference/Development/clion-setup/hive_connect_setup/#flashing","text":"Now the project can be built, the compiled code in the hive_connect.elf can be flashed on the ESP32 MCU. However, compared to the HiveMind project, the same target can't be used to just build, flash and debug. You will need to switch between targets to perform those operations. However, the build action is automatically done before flashing and debugging. Go in the target drop-down menu where you selected the target \"hive_connect_flash\". Flash the board. Once the CLion is ready and the board is connected and powered, it's possible to flash the firmware. Click on the green hammer next to the selected target. A console should be put in evidence showing the progress of the flashing process. Warning The \"hive_connect_flash\" target flashes the board with the build (\"hammer\") icon not the play icon like the \"flash\" target of the HiveMind.","title":"Flashing"},{"location":"sections/reference/Development/clion-setup/hive_connect_setup/#debugging","text":"Compared to the HiveMind firmware, the HiveConnect firmware can't be debugged directly by the OpenOCD target. This is mainly because the OpenOCD target flashes at the first address in memory of the flash and it would overwrite the bootloader present in the ESP32. Therefore, we need to flash the esp with OpenOCD with a new script and create a separate debug target to attach to the debug session. Open the target drop-down list and click on \"Edit configurations\". Add a command to flash the board with OpenOCD. First, click on the \"+\" to add a new target. Add a \"Shell Script\" target type. Fill the fields as shown below. First you will need to select \"Script text\". For the script text write ~/.espressif/tools/openocd-esp32/v0.10.0-esp32-20200709/openocd-esp32/bin/openocd -s share/openocd/scripts -f <path_to_hive connect_directory>/HiveConnect/tools/openocd/ft4232.cfg -c \"program_esp <path_to_hive connect_directory>/HiveConnect/cmake-build-debug/hive_connect.bin 0x10000\" . Also, make check sure that the option \"Execute in terminal\" is unchecked. Open the target drop-down list and click on \"Edit configurations\". Add the debug target. First, click on the \"+\" to add a new target. Add a \"Remote Debug\" target type. Fill the fields as shown below. For the debugger, if you installed all the required packages beforehand, you should be able to find the debugger at the path ~/.espressif/tools/xtensa-esp32-elf/esp-2020r3-8.4.0/xtensa-esp32-elf/bin/xtensa-esp32-elf-gdb For the target remote args: tcp:localhost:3333 For the symbol file, select the .elf generated by the build process <path_to_hive_connect_directory>/HiveConnect/cmake-build-debug/hive_connect.elf Connect and power the boards. Select the \"pre_debug_flash\" target and click on the \"play\" icon next to it. This should flash the board with OpenOCD and starts the debugging server on the MCU. A console should open to show the progress of this process. Select the \"esp_debug_gdb\" target in the target drop-down list. To start a debug session, click on the green bug icon on the right of the drop-down list. The \"Debug\" console should open and show the status of debug process by connecting to the 3333 port of the debugging session. From that point, you can use the debugger with breakpoints in your code like any debugger in an IDE. Refer to the \"Debugging\" section of the HiveMind setup to understand the debugging interface. Info Compared to the HiveMind debugging session, the debugging process is separated into two processes in parallel: The debug server launched on the MCU and the debug session launched in CLion attached to the debug server. These processes can be monitored in the \"Run\" and \"debug\" tabs separately. They can also be stopped separately, but most of the time, you will want to close both since there is no reason to keep only one running without the other.","title":"Debugging"},{"location":"sections/reference/Development/clion-setup/hive_mind_setup/","text":"Building the project Open CLion Open the HiveMind folder. Go in \"File->Open\", found the path to the root of the HiveMind repository and click \"Open\". After that step, you should the project directory on the right of the screen. Configure the toolchain. This step selects the build tool and compiler for the CMake profile. Go to \"File->Settings\". On the right menu go to \"Build, Execution, Deployment->Toolchains\". Set all the fields as follows: Configure the Cmake profile. Go to \"File->Settings\". This step set the build type and selects the toolchain file to build for the STM32H735ZG. On the right menu go to \"Build, Execution, Deployment->CMake\". Set all the fields as follow: You can copy the \"Cmake options\" line: -D CMAKE_TOOLCHAIN_FILE=<path_to_hivemind_directory>/HiveMind/cmake/stm32_h735zg_gcc.cmake Build the project. In the right corner, in the target drop-down menu (see image below) select the target named \"hive_mind.elf\". To build the project, just click on the green hammer next to the drop-down menu. You can follow the building process in the \"Message\" tab console. Important Don't start the build if the CMake has not finished its job. You can follow the progress of the CMake job in the \"CMake\" console tab at the bottom of the IDE. You can also follow the progress of the building process in the \"Messages\" tab. Flashing Now the project can be built, the compiled code in the hive_mind.elf can be flashed on the STM32 MCU. Even if a target could be created to only flash the board, we gonna create a target that will be able to both flash and debug the board. Thanks to the support of OpenOCD in CLion, this integration should be easy. Go in the target drop-down menu where you selected the target \"hive_mind.elf\" and select \"Edit Configurations\" which should be the top item of the list. In the top left corner of the new menu, click on the \"+\" to add a new configuration and select \"OpenOCD Download & Run\". Fill the fields like shown in the image above. Make sure to enter the path of hiveboard.cfg on your machine. It should be found at <path_to_hivemind_directory>/HiveMind/tools/openocd/stm32_h7/hiveboard.cfg Plug the board as shown in the Basic Examples except that you don't need the connection to an embedded computer to flash the board. Flash the board. Since the CLion is now ready and the board is connected and powered, it's possible to flash the firmware. In the right corner, in the target drop-down menu (see image below) select the target named \"flash\" it should appear at the bottom of the list. It corresponds to the configuration created a few steps above. You can then flash the board by clicking on the play button next to the configuration file. A console should open at the bottom of the IDE showing the status of the flashing process. Hint The \"Flash\" target created in the steps above can also be used to build the code by clicking on the green hammer. Therefore, you don't need to change the target to the \"hive_mind.elf\" to build the project anymore and can only use the \"Flash\" target. Debugging Since CLion supports well OpenOCD, the HiveMind firmware can easily be debugged from the CLion IDE. If not done, follow the instructions in the \"Building the project\" and \"Flashing\" sections above. The target created in steps 2 and 3 of the \"Flashing\" section is used for debugging. Select the target name \"Flash\" that was created in the steps above. Connect and power the boards. To start a debug session, click on the green bug icon on the right of the drop-down list. (Look at the last image of the \"Flashing \" section). The \"Debug\" console should open and show the status of debugging process by opening a GDB port on port 3333. From that point, you can use the debugger with breakpoints in your code like any debugger in an IDE. The red rectangle below shows the main section of the debugger that you will likely use. Other debugging features Two other features might be interesting to use for debugging. Internal registers display The first one is to set up the STM32's .svd file in the debugger to visualize the value of the internal registers of the MCU. Go to the \"Peripherals\" tab (shown with an arrow in the above image presenting the debugger interface). Click on the \"Load .svd file. If the text option is not present, click on the \"Funnel\" icon on the inner vertical column to the left of the console to configure the .svd files. The path of the .svd for the STM32H7 should be found at <path_to_hivemind_directory>/HiveMind/tools/svd_map/stm32h73x.svd Check the box of the uppermost configuration to display all the available inner registers. Click Ok Now, in the \"Peripherals\" tab you should see a list of registers. The next time you will be debugging, those registers should reflect the actual registers of the MCU. RTOS analysis tool The second feature that might be useful is the RTOS analysis tools. Since the HiveMind firmware uses FreeRTOS to create tasks which act as virtual threads, it's interesting to view the call stack of each of those tasks separately instead of seeing the main thread of the MCU. Activate the RTOS integration. Go in \"Files->Settings\". Then go in \"Build, Execution, Deployment - > Embedded Development->RTOS Integration\". Check the box \"Enable RTOS Integration\" and select \"Auto\" of \"FreeRTOS\". Next time in the debugging console you should see that you can select the call stack of the desired RTOS task you want. Also, you can see all the task and their status.","title":"HiveMind CLion setup"},{"location":"sections/reference/Development/clion-setup/hive_mind_setup/#building-the-project","text":"Open CLion Open the HiveMind folder. Go in \"File->Open\", found the path to the root of the HiveMind repository and click \"Open\". After that step, you should the project directory on the right of the screen. Configure the toolchain. This step selects the build tool and compiler for the CMake profile. Go to \"File->Settings\". On the right menu go to \"Build, Execution, Deployment->Toolchains\". Set all the fields as follows: Configure the Cmake profile. Go to \"File->Settings\". This step set the build type and selects the toolchain file to build for the STM32H735ZG. On the right menu go to \"Build, Execution, Deployment->CMake\". Set all the fields as follow: You can copy the \"Cmake options\" line: -D CMAKE_TOOLCHAIN_FILE=<path_to_hivemind_directory>/HiveMind/cmake/stm32_h735zg_gcc.cmake Build the project. In the right corner, in the target drop-down menu (see image below) select the target named \"hive_mind.elf\". To build the project, just click on the green hammer next to the drop-down menu. You can follow the building process in the \"Message\" tab console. Important Don't start the build if the CMake has not finished its job. You can follow the progress of the CMake job in the \"CMake\" console tab at the bottom of the IDE. You can also follow the progress of the building process in the \"Messages\" tab.","title":"Building the project"},{"location":"sections/reference/Development/clion-setup/hive_mind_setup/#flashing","text":"Now the project can be built, the compiled code in the hive_mind.elf can be flashed on the STM32 MCU. Even if a target could be created to only flash the board, we gonna create a target that will be able to both flash and debug the board. Thanks to the support of OpenOCD in CLion, this integration should be easy. Go in the target drop-down menu where you selected the target \"hive_mind.elf\" and select \"Edit Configurations\" which should be the top item of the list. In the top left corner of the new menu, click on the \"+\" to add a new configuration and select \"OpenOCD Download & Run\". Fill the fields like shown in the image above. Make sure to enter the path of hiveboard.cfg on your machine. It should be found at <path_to_hivemind_directory>/HiveMind/tools/openocd/stm32_h7/hiveboard.cfg Plug the board as shown in the Basic Examples except that you don't need the connection to an embedded computer to flash the board. Flash the board. Since the CLion is now ready and the board is connected and powered, it's possible to flash the firmware. In the right corner, in the target drop-down menu (see image below) select the target named \"flash\" it should appear at the bottom of the list. It corresponds to the configuration created a few steps above. You can then flash the board by clicking on the play button next to the configuration file. A console should open at the bottom of the IDE showing the status of the flashing process. Hint The \"Flash\" target created in the steps above can also be used to build the code by clicking on the green hammer. Therefore, you don't need to change the target to the \"hive_mind.elf\" to build the project anymore and can only use the \"Flash\" target.","title":"Flashing"},{"location":"sections/reference/Development/clion-setup/hive_mind_setup/#debugging","text":"Since CLion supports well OpenOCD, the HiveMind firmware can easily be debugged from the CLion IDE. If not done, follow the instructions in the \"Building the project\" and \"Flashing\" sections above. The target created in steps 2 and 3 of the \"Flashing\" section is used for debugging. Select the target name \"Flash\" that was created in the steps above. Connect and power the boards. To start a debug session, click on the green bug icon on the right of the drop-down list. (Look at the last image of the \"Flashing \" section). The \"Debug\" console should open and show the status of debugging process by opening a GDB port on port 3333. From that point, you can use the debugger with breakpoints in your code like any debugger in an IDE. The red rectangle below shows the main section of the debugger that you will likely use.","title":"Debugging"},{"location":"sections/reference/Development/clion-setup/hive_mind_setup/#other-debugging-features","text":"Two other features might be interesting to use for debugging.","title":"Other debugging features"},{"location":"sections/reference/Development/clion-setup/hive_mind_setup/#internal-registers-display","text":"The first one is to set up the STM32's .svd file in the debugger to visualize the value of the internal registers of the MCU. Go to the \"Peripherals\" tab (shown with an arrow in the above image presenting the debugger interface). Click on the \"Load .svd file. If the text option is not present, click on the \"Funnel\" icon on the inner vertical column to the left of the console to configure the .svd files. The path of the .svd for the STM32H7 should be found at <path_to_hivemind_directory>/HiveMind/tools/svd_map/stm32h73x.svd Check the box of the uppermost configuration to display all the available inner registers. Click Ok Now, in the \"Peripherals\" tab you should see a list of registers. The next time you will be debugging, those registers should reflect the actual registers of the MCU.","title":"Internal registers display"},{"location":"sections/reference/Development/clion-setup/hive_mind_setup/#rtos-analysis-tool","text":"The second feature that might be useful is the RTOS analysis tools. Since the HiveMind firmware uses FreeRTOS to create tasks which act as virtual threads, it's interesting to view the call stack of each of those tasks separately instead of seeing the main thread of the MCU. Activate the RTOS integration. Go in \"Files->Settings\". Then go in \"Build, Execution, Deployment - > Embedded Development->RTOS Integration\". Check the box \"Enable RTOS Integration\" and select \"Auto\" of \"FreeRTOS\". Next time in the debugging console you should see that you can select the call stack of the desired RTOS task you want. Also, you can see all the task and their status.","title":"RTOS analysis tool"},{"location":"sections/reference/Development/clion-setup/logging/","text":"The HiveMind and the HiveConnect log different types of information through different serial ports. Thanks to the FTDI chips on the HiveBoard, all those ports are available through the single USB port of the board. Although you can use your favourite programs like screen or Putty to monitor what is happening on those serial ports, you can directly add a plug-in in CLion to do so. Go in \"Files->Settings\". Go to the \"Plugins\" menu. Click in the tab \"Marketplace\" at the top of the menu and search for the \"Serial Port Monitor\" plugin by Dmitry Cherkas and install it. Connect the USB cable from the board to the PC and power the board. Connect to the serial port of the logging MCU. With step 1 completed, a new tab named \"Serial Port\" should be found in the consoles area. Click on the \"Wrench\" to configure the ports. Set the \"Baudrate\" to 115200 For the \"Port name\", it depends if you want to log information from the HivemMind or HiveConnect. Port name Description /dev/ttyUSB0 JTAG of the STM32. Used to program the STM32. (Don't connect to this one) /dev/ttyUSB1 JTAG of the ESP32. Used to program the ESP32. (Don't connect to this one) /dev/ttyUSB2 Logging output of the HiveMind (STM32) /dev/ttyUSB3 Logging output of the HiveConnect (ESP32) Info The JTAG port of the STM32 and ESP32 might not be visible in the drop-down list if you just flashed the firmware on one either of them. Also, the port might not be mapped from USB0 to USB3 if there are other USB devices connected. 4.Once the Baudrate and the Port Name are set, connect to the port by clicking on the Connect Icon. After this, you should see the console filling with a message from the selected board. Info If the messages are in hexadecimal instead of being in text, try to switch back to text mode by clicking on the button shown below.","title":"Logging in CLion"},{"location":"sections/reference/HiveAR/hivear-commands/","text":"Swarm agents commands: Agents in the same swarm than the Android device are listed in the Commands tab. Swarm agents list If selected, commands specific to this agent are then listed and can be used to directly send command to this agent. Agent commands Tip If an agent doesn't have its comands listed, it is possible to force to refresh its commands with the refresh button. Same goes for listing swarm agents. Commands in augmented reality It is also possible to fetch and send commands directly from the augmented reality tab when targetting a specific agent. Refer to visualisation section for more information on this view for any other questions other than commands. AR identification example Attention Application only supports integer or float arguments modification for commands inside this view. If any argument has another type, it is still possible to send from AR view, but with the already defined value. If one wants to change that value, it can be edited inside the agent commands view . Swarm broadcast commands: It is possible to send commands to all agents in the swarm. In order to register commands to broadcast, the user has to long press any command from the agents commands view or device commands view and then accept. Registered commands would then be separated between host and buzz command types and can both be sent to any agent. Attention Not every sent broadcast command will be handled be every agent depending on whether the agent can handle this command. If an agent can't handle the command, it will simply discard it. Device Buzz commands: As any other agent in the swarm, it is possible that the HiveBoard connected to the Android device has its own Buzz commands registered. It is from the tab named Local Buzz that the user can use those commands. Tip Buzz commands can easily be recognized accross the application with the following icon beside the command's name:","title":"Sending Commands"},{"location":"sections/reference/HiveAR/hivear-commands/#swarm-agents-commands","text":"Agents in the same swarm than the Android device are listed in the Commands tab. Swarm agents list If selected, commands specific to this agent are then listed and can be used to directly send command to this agent. Agent commands Tip If an agent doesn't have its comands listed, it is possible to force to refresh its commands with the refresh button. Same goes for listing swarm agents.","title":"Swarm agents commands: "},{"location":"sections/reference/HiveAR/hivear-commands/#commands-in-augmented-reality","text":"It is also possible to fetch and send commands directly from the augmented reality tab when targetting a specific agent. Refer to visualisation section for more information on this view for any other questions other than commands. AR identification example Attention Application only supports integer or float arguments modification for commands inside this view. If any argument has another type, it is still possible to send from AR view, but with the already defined value. If one wants to change that value, it can be edited inside the agent commands view .","title":"Commands in augmented reality"},{"location":"sections/reference/HiveAR/hivear-commands/#swarm-broadcast-commands","text":"It is possible to send commands to all agents in the swarm. In order to register commands to broadcast, the user has to long press any command from the agents commands view or device commands view and then accept. Registered commands would then be separated between host and buzz command types and can both be sent to any agent. Attention Not every sent broadcast command will be handled be every agent depending on whether the agent can handle this command. If an agent can't handle the command, it will simply discard it.","title":"Swarm broadcast commands: "},{"location":"sections/reference/HiveAR/hivear-commands/#device-buzz-commands","text":"As any other agent in the swarm, it is possible that the HiveBoard connected to the Android device has its own Buzz commands registered. It is from the tab named Local Buzz that the user can use those commands. Tip Buzz commands can easily be recognized accross the application with the following icon beside the command's name:","title":"Device Buzz commands: "},{"location":"sections/reference/HiveAR/hivear-configuration/","text":"Hiveboard Network Configuration Please refer to this section for information about setting the network configuration (such as SSID and password) of a Hiveboard. Associate AprilTags to an Agent in the Swarm: To use augmented reality, AprilTags must be useed to identify swarm agents. AprilTags are incoded integers that are used as unique identifiers inside of HiveAR. By default, a tag's id will be associated to the same agent id. Hence, an AprilTag #1 will be considered attached to the swarm agent with id 1. It is possible to override this behaviour by associating manually AprilTags with agent ids. In the settings tab, one can make any wanted associations for the session. Example of association Tip One agent can have multiple different AprilTags associated with, or can have multiple physical AprilTag with same value on top of the agent. Attention It is not possible to associate the same AprilTag to different agents.","title":"Configuration"},{"location":"sections/reference/HiveAR/hivear-configuration/#hiveboard-network-configuration","text":"Please refer to this section for information about setting the network configuration (such as SSID and password) of a Hiveboard.","title":"Hiveboard Network Configuration"},{"location":"sections/reference/HiveAR/hivear-configuration/#associate-apriltags-to-an-agent-in-the-swarm","text":"To use augmented reality, AprilTags must be useed to identify swarm agents. AprilTags are incoded integers that are used as unique identifiers inside of HiveAR. By default, a tag's id will be associated to the same agent id. Hence, an AprilTag #1 will be considered attached to the swarm agent with id 1. It is possible to override this behaviour by associating manually AprilTags with agent ids. In the settings tab, one can make any wanted associations for the session. Example of association Tip One agent can have multiple different AprilTags associated with, or can have multiple physical AprilTag with same value on top of the agent. Attention It is not possible to associate the same AprilTag to different agents.","title":"Associate AprilTags to an Agent in the Swarm: "},{"location":"sections/reference/HiveAR/hivear-preface/","text":"HiveAR preface HiveAR is the Android application that makes the user interact with the swarm directly when a HiveBoard is connected to the Android device. The codebase for HiveAR is hosted on GitHub . More information can be found on how to setup an Android device with a HiveBoard here . Its primary roles are defined as follows: Send commands to the agents in the swarm Visualize the states of the agents in the swarm Through augmented reality (AR) With runtime logs Configure the swarm and its agents HiveBoard network configuration (From Networking reference section) Agents' associated AprilTags definition","title":"About HiveAR"},{"location":"sections/reference/HiveAR/hivear-preface/#hivear-preface","text":"HiveAR is the Android application that makes the user interact with the swarm directly when a HiveBoard is connected to the Android device. The codebase for HiveAR is hosted on GitHub . More information can be found on how to setup an Android device with a HiveBoard here . Its primary roles are defined as follows: Send commands to the agents in the swarm Visualize the states of the agents in the swarm Through augmented reality (AR) With runtime logs Configure the swarm and its agents HiveBoard network configuration (From Networking reference section) Agents' associated AprilTags definition","title":"HiveAR preface"},{"location":"sections/reference/HiveAR/hivear-setup/","text":"In order to use HiveAR, first download the application from the GitHub page and install accordingly to the instructions in the same page. Connect the Android Device to a physical HiveBoard Wire Things Up To connect the HiveAR app running on an Android device to a HiveBoard, you must first disconnect the Ethernet cable from the HiveBoard . Then, plug the micro-USB cable from the HiveBoard to the Android Device as shown in the image below. Also, make sure that the DIP switches for the WROOM ESP-32 module are at the correct position to enable Wi-Fi capabilities. Refer to the HiveBoard UI page for more on this. Hint Why must the Ethernet cable be disconnected? A HiveBoard can only be connected to one host at a time (be it a robot runnung HiveMindBridge , usually connected vie Ethernet, or an Android device running HiveAR). If the HiveBoard and the robot's embedded computer already have a connection established, it will be impossible to establish a second connection to the Android device. Thus, we advise that you unplug the Ethernet cable prior to using HiveAR with a given HiveBoard. Establish the connection between HiveAR and HiveMind via USB Launch the HiveAR application on the Android device. Accept the different permission requests. Navigate to the Connection tab (first icon on the left at the base of the screen). Click on the circular button containing two arrows pointing at each other in the lower left side of the screen. A selection bar will appear at the top of the screen: Tap on the bar and select option HiveBoard: HiveMind . Then tap Connect. The logs (under Incoming Data ) should show that the greet messages have been exchanged and you should see a green dot appear near the Connection button at the lower left of the screen. HiveAR and HiveMind are now connected. Connect the Android Device to a Simulated HiveBoard The HiveMind firmware can be run on a Linux computer to simulate a HiveBoard. Connection to the HiveAR application is then done using TCP/IP. As the HiveMind running on a HiveBoard is considered client, the Android device running HiveAR would be server. Different implementation can be done to achieve this. An example can be found in the SwarmUS-ROS project , where an Android device can be associated to a simulated HiveBoard running in a ROS node. The launch file associated to this implementation can be found here . Having the Android device being the server, the client must know what IP address and port to connect to: this is found in the connection tab when switching to remote mode. There, the current network IP adress of the Android device is show and it is possible to choose which port to listen for incoming connection. To have the remote connection view, click on the round button beside button \"Disconnect\". In remote view, a signal bar icon is displayed on that round button. Remote connection view After port is set, press connect to start listening on that port for incoming connection whenever the client is trying to connect. Attention When listening for an incoming connection in remote mode, HiveAR is listening for an incoming connection for 10 seconds. Just click on connect button again if desired. Connection Status As the Android device must be connected either by USB or TCP to communicate to the swarm, it is possible to keep track of the state of the connection with the swarm. A small coloured dot has been add to the connection tab icon and can be observed as followed: The dot can have four states: Red: Android device not connected Blue: Android device trying to establish connection with HiveMind Yellow: Android device connected to HiveMind, but HiveAR is not registered as part of the swarm Green: Android device is connected to HiveMind And HiveAR registered as part of the swarm Not connected status indicator Connecting to HiveMind status indicator Connected, HiveAR not registered in swarm Connected to swarm, with logs Attention Always make sure connection with the swarm is established and working correctly (green round icon) before trying to use any swarm features. In the case where there is a problem with the connection, one can always return to the connection page to try to establish the connection again.","title":"Setup HiveAR"},{"location":"sections/reference/HiveAR/hivear-setup/#connect-the-android-device-to-a-physical-hiveboard","text":"","title":"Connect the Android Device to a physical HiveBoard"},{"location":"sections/reference/HiveAR/hivear-setup/#wire-things-up","text":"To connect the HiveAR app running on an Android device to a HiveBoard, you must first disconnect the Ethernet cable from the HiveBoard . Then, plug the micro-USB cable from the HiveBoard to the Android Device as shown in the image below. Also, make sure that the DIP switches for the WROOM ESP-32 module are at the correct position to enable Wi-Fi capabilities. Refer to the HiveBoard UI page for more on this. Hint Why must the Ethernet cable be disconnected? A HiveBoard can only be connected to one host at a time (be it a robot runnung HiveMindBridge , usually connected vie Ethernet, or an Android device running HiveAR). If the HiveBoard and the robot's embedded computer already have a connection established, it will be impossible to establish a second connection to the Android device. Thus, we advise that you unplug the Ethernet cable prior to using HiveAR with a given HiveBoard.","title":"Wire Things Up"},{"location":"sections/reference/HiveAR/hivear-setup/#establish-the-connection-between-hivear-and-hivemind-via-usb","text":"Launch the HiveAR application on the Android device. Accept the different permission requests. Navigate to the Connection tab (first icon on the left at the base of the screen). Click on the circular button containing two arrows pointing at each other in the lower left side of the screen. A selection bar will appear at the top of the screen: Tap on the bar and select option HiveBoard: HiveMind . Then tap Connect. The logs (under Incoming Data ) should show that the greet messages have been exchanged and you should see a green dot appear near the Connection button at the lower left of the screen. HiveAR and HiveMind are now connected.","title":"Establish the connection between HiveAR and HiveMind via USB"},{"location":"sections/reference/HiveAR/hivear-setup/#connect-the-android-device-to-a-simulated-hiveboard","text":"The HiveMind firmware can be run on a Linux computer to simulate a HiveBoard. Connection to the HiveAR application is then done using TCP/IP. As the HiveMind running on a HiveBoard is considered client, the Android device running HiveAR would be server. Different implementation can be done to achieve this. An example can be found in the SwarmUS-ROS project , where an Android device can be associated to a simulated HiveBoard running in a ROS node. The launch file associated to this implementation can be found here . Having the Android device being the server, the client must know what IP address and port to connect to: this is found in the connection tab when switching to remote mode. There, the current network IP adress of the Android device is show and it is possible to choose which port to listen for incoming connection. To have the remote connection view, click on the round button beside button \"Disconnect\". In remote view, a signal bar icon is displayed on that round button. Remote connection view After port is set, press connect to start listening on that port for incoming connection whenever the client is trying to connect. Attention When listening for an incoming connection in remote mode, HiveAR is listening for an incoming connection for 10 seconds. Just click on connect button again if desired.","title":"Connect the Android Device to a Simulated HiveBoard"},{"location":"sections/reference/HiveAR/hivear-setup/#connection-status","text":"As the Android device must be connected either by USB or TCP to communicate to the swarm, it is possible to keep track of the state of the connection with the swarm. A small coloured dot has been add to the connection tab icon and can be observed as followed: The dot can have four states: Red: Android device not connected Blue: Android device trying to establish connection with HiveMind Yellow: Android device connected to HiveMind, but HiveAR is not registered as part of the swarm Green: Android device is connected to HiveMind And HiveAR registered as part of the swarm Not connected status indicator Connecting to HiveMind status indicator Connected, HiveAR not registered in swarm Connected to swarm, with logs Attention Always make sure connection with the swarm is established and working correctly (green round icon) before trying to use any swarm features. In the case where there is a problem with the connection, one can always return to the connection page to try to establish the connection again.","title":"Connection Status"},{"location":"sections/reference/HiveAR/hivear-visualization/","text":"One of the main goal of the HiveAR app is to visualize the state of the Swarm directly from an Android device. Augmented Reality (AR): Augmented Reality is a quick diagnostic tool that is used mostly to get the immediate state of visible agents, but also to send commands to specific agents. At a close range, if the device is pointed towards the AprilTag on top of a specific agent, details of this agent will appear on top of it. Attention April tags are not detected from afar, which is why to scan it, it should be better to direct the android device directly at the tag from a distance about 0.8 to 1.2 meters. (Results might vary from the device's camera resolution) Information contained in that view are: Last time agent was updated Status of the agent (User must define the comportement as it can differ from one agent to the next) Last commands sent from the Android device to the agent Commands associated to the selected agent that can be sent AR agent selected example Note It is possible to have an AR marker in the space without being on top of an agent if this agent has moved and the Android device hasn't detected it. It will still monitor the agent even if it is not on top of it, but if one desire to remove the marker, simply long click it and agree to remove it. Tip If multiple agents are detected, it is possible to focus on one by clicking its corresponding AR marker. (arrow) Messages Logging: Logs are a great way to know what information came from or to the Android device. They can be found in the Connection tab. They can help to see if a command came through, or what were the arguments of the incoming function call. Tip Logs can be shortened or detailed whenever needed with the \"Detailed logs\" checkbox.","title":"Swarm Visualization"},{"location":"sections/reference/HiveAR/hivear-visualization/#augmented-reality-ar","text":"Augmented Reality is a quick diagnostic tool that is used mostly to get the immediate state of visible agents, but also to send commands to specific agents. At a close range, if the device is pointed towards the AprilTag on top of a specific agent, details of this agent will appear on top of it. Attention April tags are not detected from afar, which is why to scan it, it should be better to direct the android device directly at the tag from a distance about 0.8 to 1.2 meters. (Results might vary from the device's camera resolution) Information contained in that view are: Last time agent was updated Status of the agent (User must define the comportement as it can differ from one agent to the next) Last commands sent from the Android device to the agent Commands associated to the selected agent that can be sent AR agent selected example Note It is possible to have an AR marker in the space without being on top of an agent if this agent has moved and the Android device hasn't detected it. It will still monitor the agent even if it is not on top of it, but if one desire to remove the marker, simply long click it and agree to remove it. Tip If multiple agents are detected, it is possible to focus on one by clicking its corresponding AR marker. (arrow)","title":"Augmented Reality (AR): "},{"location":"sections/reference/HiveAR/hivear-visualization/#messages-logging","text":"Logs are a great way to know what information came from or to the Android device. They can be found in the Connection tab. They can help to see if a command came through, or what were the arguments of the incoming function call. Tip Logs can be shortened or detailed whenever needed with the \"Detailed logs\" checkbox.","title":"Messages Logging: "},{"location":"sections/reference/HiveMind/hivemind-api/","text":"HiveMind API The HiveMind provides an API via protobuf for the host which allows it to get information on the swarm (neighbors, swarmlist, distance of a neighbor, etc), act on it or more. Most of the swarm decisions should be made via the Buzz script to separate the logic of the swarm and its action on the world. However, sometimes more computing power can be requried, which can be done on the host if needed. Thus the host has acces to an API. Note The HiveMind API is implemented as a set of Protocol Buffer messages. This means that any program could interact with the HiveMind API, as long as it uses the same message definition. For instance, in the SwarmUS platform, HiveMindBridge , HiveConnect , HiveAR , and the Python testbench use the HiveMind API. The messages for HiveMind API are defined in the Pheromones repository . In the SwarmUS codebase, the Pheromones message definitions have been further wrapped for C++ specifically, since this is the language used in most of the stack. The C++ wrapping is included in the Propolis repository as the propolis-pheromones library. Note that the host should only use a subset of the messages. The whole message hierarchy is provided for a better understanding of the inner workings. Only the Request and Response messages (and those composed in it) are for the user/host to call, the others are internal messages for swarm functionalities. Here is the message hierarchy: Here is a description of the Messages: Request and Response: Requests and Reponses available for the user. GenericResponse: A generic response can be used to indicate success or failure. The details field can be used to log on the other side. When there is no payload on a request, a GenericResponse is used as an ACK. UserCall: Regroup multiple messages. All UserCalls can be to/from Buzz or the host. FunctionCall: Used to call a function to a host or Buzz script. The function name needs to match the one that was registered, the number of arguments and their types needs to match. FunctionListLength: Used to get the total number of registered functions. See FunctionDescription FunctionDescription: To obtain the description of a function, such as its name, number of arguments, arguments name and the arguments types. Note that you access function descriptions by list index, which starts at 0. So if the function list length is 5, the valid list indexes are [0,1,2,3,4]. HiveMindHostAPI: API that the HiveMind exposes to the host, this includes an API for the interlocalisation, bytes and swarmlist Bytes: A request used to send bytes, ACK with a generic response. Note that each Bytes message is a packet of a bigger payload, you can reassemble the total packet with the packet id, packet number and a boolean that identifies the last packet. You need to concatenate the data to get the original byte stream. Neighbor: Get the information on a particular neighbor (distance, orientation, line of sight). NeighborsList: Get a list of ids containing the current neighbors. Note that you only get their id, you need to make a Neighbor Request to obtain the data. SwarmList: Get a list of ids containing the current agents in the swarm. Greeting: The first message sent to the HiveMind needs to be a greet (can be with garbage value). The HiveMind will reply with a Greet with its ID, allowing the host to know its id in the swarm. This is required to make requests in the swarm. The greeting should be the first thing to be sent on connection. NetworkAPI: Internal message to manage connections with other members in the swarm. Not relevant to the user. IpDiscovery: Used to discover new IP addresses in the network. InterlocAPI: Internal messages used to calibrate and extract data from the interlocalisation engine. These messages are mostly used in the TestBench-Python repository . The most notable messages are: ConfigureAngleParameters: Used to send a calibration back to the HiveBoard so it can be saved in its non-volatile memory. InterlocRawAngleData: Used to send raw DW1000 register data back to the PC in order to calculate calibration parameters. InterlocDump: Periodic dump of calculated localization data. Used to verify validity of the data after the calculation algorithms have been applied. BuzzMessage: Internal message to Buzz to share data between the virtual machines in the swarm.","title":"HiveMind API"},{"location":"sections/reference/HiveMind/hivemind-api/#hivemind-api","text":"The HiveMind provides an API via protobuf for the host which allows it to get information on the swarm (neighbors, swarmlist, distance of a neighbor, etc), act on it or more. Most of the swarm decisions should be made via the Buzz script to separate the logic of the swarm and its action on the world. However, sometimes more computing power can be requried, which can be done on the host if needed. Thus the host has acces to an API. Note The HiveMind API is implemented as a set of Protocol Buffer messages. This means that any program could interact with the HiveMind API, as long as it uses the same message definition. For instance, in the SwarmUS platform, HiveMindBridge , HiveConnect , HiveAR , and the Python testbench use the HiveMind API. The messages for HiveMind API are defined in the Pheromones repository . In the SwarmUS codebase, the Pheromones message definitions have been further wrapped for C++ specifically, since this is the language used in most of the stack. The C++ wrapping is included in the Propolis repository as the propolis-pheromones library. Note that the host should only use a subset of the messages. The whole message hierarchy is provided for a better understanding of the inner workings. Only the Request and Response messages (and those composed in it) are for the user/host to call, the others are internal messages for swarm functionalities. Here is the message hierarchy: Here is a description of the Messages: Request and Response: Requests and Reponses available for the user. GenericResponse: A generic response can be used to indicate success or failure. The details field can be used to log on the other side. When there is no payload on a request, a GenericResponse is used as an ACK. UserCall: Regroup multiple messages. All UserCalls can be to/from Buzz or the host. FunctionCall: Used to call a function to a host or Buzz script. The function name needs to match the one that was registered, the number of arguments and their types needs to match. FunctionListLength: Used to get the total number of registered functions. See FunctionDescription FunctionDescription: To obtain the description of a function, such as its name, number of arguments, arguments name and the arguments types. Note that you access function descriptions by list index, which starts at 0. So if the function list length is 5, the valid list indexes are [0,1,2,3,4]. HiveMindHostAPI: API that the HiveMind exposes to the host, this includes an API for the interlocalisation, bytes and swarmlist Bytes: A request used to send bytes, ACK with a generic response. Note that each Bytes message is a packet of a bigger payload, you can reassemble the total packet with the packet id, packet number and a boolean that identifies the last packet. You need to concatenate the data to get the original byte stream. Neighbor: Get the information on a particular neighbor (distance, orientation, line of sight). NeighborsList: Get a list of ids containing the current neighbors. Note that you only get their id, you need to make a Neighbor Request to obtain the data. SwarmList: Get a list of ids containing the current agents in the swarm. Greeting: The first message sent to the HiveMind needs to be a greet (can be with garbage value). The HiveMind will reply with a Greet with its ID, allowing the host to know its id in the swarm. This is required to make requests in the swarm. The greeting should be the first thing to be sent on connection. NetworkAPI: Internal message to manage connections with other members in the swarm. Not relevant to the user. IpDiscovery: Used to discover new IP addresses in the network. InterlocAPI: Internal messages used to calibrate and extract data from the interlocalisation engine. These messages are mostly used in the TestBench-Python repository . The most notable messages are: ConfigureAngleParameters: Used to send a calibration back to the HiveBoard so it can be saved in its non-volatile memory. InterlocRawAngleData: Used to send raw DW1000 register data back to the PC in order to calculate calibration parameters. InterlocDump: Periodic dump of calculated localization data. Used to verify validity of the data after the calculation algorithms have been applied. BuzzMessage: Internal message to Buzz to share data between the virtual machines in the swarm.","title":"HiveMind API"},{"location":"sections/reference/HiveMind/hivemind-host/","text":"HiveMind and the Host The host robot generally only provides functionalities to interact with the physical world and should not have swarm related decision. Once connected, the HiveMind will coordinate the swarm and use the calls provided by the robot to interact with the physical world. In other words, the robot is passive and the decisions are made by the Buzz script. For example, the HiveMind could request the robot to move to an x,y position, relative to its current position, thus the \"moveBy\" function would be called on the host. Communication The HiveMind needs to communicate with the host and this is generally done via TCP or USB. The communication is done with Google's Protocol Buffer, you can find the definition of the Protocol buffer in the Pheromone repo . Note that for every repeated field, there is a limit, which is configurable at configure time with CMake, see here . Changin the values will affect the ram usage. Scheme The HiveMind communicates via protobuf messages with the host. One can send a Request and the other will respond with a Response message. Note that this doesn't mean request are sequential. If you send a Request to the HiveMind, the next message will not necessarily be the Response you just requested, you should treat messages as events and handle them accordingly, not as an atomic transaction. Only the Request and Response messages (and those composed in it) are for the user to call, the others are internal messages for swarm functionalities. To be a host you need to implement all the functionalities in the Request and Response messages, since this can be time consuming, a C++ implementation is already provided here . Then you can register simply register your required functions.","title":"HiveMind and the Host"},{"location":"sections/reference/HiveMind/hivemind-host/#hivemind-and-the-host","text":"The host robot generally only provides functionalities to interact with the physical world and should not have swarm related decision. Once connected, the HiveMind will coordinate the swarm and use the calls provided by the robot to interact with the physical world. In other words, the robot is passive and the decisions are made by the Buzz script. For example, the HiveMind could request the robot to move to an x,y position, relative to its current position, thus the \"moveBy\" function would be called on the host.","title":"HiveMind and the Host"},{"location":"sections/reference/HiveMind/hivemind-host/#communication","text":"The HiveMind needs to communicate with the host and this is generally done via TCP or USB. The communication is done with Google's Protocol Buffer, you can find the definition of the Protocol buffer in the Pheromone repo . Note that for every repeated field, there is a limit, which is configurable at configure time with CMake, see here . Changin the values will affect the ram usage.","title":"Communication"},{"location":"sections/reference/HiveMind/hivemind-host/#scheme","text":"The HiveMind communicates via protobuf messages with the host. One can send a Request and the other will respond with a Response message. Note that this doesn't mean request are sequential. If you send a Request to the HiveMind, the next message will not necessarily be the Response you just requested, you should treat messages as events and handle them accordingly, not as an atomic transaction. Only the Request and Response messages (and those composed in it) are for the user to call, the others are internal messages for swarm functionalities. To be a host you need to implement all the functionalities in the Request and Response messages, since this can be time consuming, a C++ implementation is already provided here . Then you can register simply register your required functions.","title":"Scheme"},{"location":"sections/reference/HiveMind/hivemind-preface/","text":"About HiveMind The HiveMind (HM) is the firmware that runs on the HiveBoard STM32 MCU or on Linux with ROS. The HiveMind is connected to a host robot and the rest of the swarm. It then orchestrates the logic of the swarm and sends messages to the host or other members in the swarm accordingly. The codebase for HiveMind is hosted on GitHub . The HiveMind has multiple roles in the swarm: It runs the BBVM (BittyBuzz Virtual Machine) , which executes the user code that defines the behavior of the swarm. Routes the messages from one component to the other which includes The host The BBVM Other agents in the swarm The communication between the components of the swarm is generally handled by the HiveConnect Provides an API for the host robot . The API allows to: Get the list of robots currently in the whole swarm network Get the current neighbors of a robot Get information on a neighbor such as distance, angle and if the neighbor is in the line of sight (LOS) Send bytes to another robot in the swarm Call a function of another robot in the swarm Call a buzz function in the swarm","title":"About HiveMind"},{"location":"sections/reference/HiveMind/hivemind-preface/#about-hivemind","text":"The HiveMind (HM) is the firmware that runs on the HiveBoard STM32 MCU or on Linux with ROS. The HiveMind is connected to a host robot and the rest of the swarm. It then orchestrates the logic of the swarm and sends messages to the host or other members in the swarm accordingly. The codebase for HiveMind is hosted on GitHub . The HiveMind has multiple roles in the swarm: It runs the BBVM (BittyBuzz Virtual Machine) , which executes the user code that defines the behavior of the swarm. Routes the messages from one component to the other which includes The host The BBVM Other agents in the swarm The communication between the components of the swarm is generally handled by the HiveConnect Provides an API for the host robot . The API allows to: Get the list of robots currently in the whole swarm network Get the current neighbors of a robot Get information on a neighbor such as distance, angle and if the neighbor is in the line of sight (LOS) Send bytes to another robot in the swarm Call a function of another robot in the swarm Call a buzz function in the swarm","title":"About HiveMind"},{"location":"sections/reference/HiveMind/hivemind-swarm/","text":"HiveMind and the Swarm The HiveMind makes uses of function calls as ways to interact with different components and those functions are called by name. As a user, you define the functions in the Buzz script or on the host and use them between the components. The functions are registered with a description of arguments (name and type) and a callback (the actual function). It is then possible to call this function from another component in the swarm. Those functions calls do not have return values, so instead it's possible to call another function and the \"return value\" will be an argument of the function call. For example: if the Buzz script calls getStatus() on its local host, the message is routed by the HiveMind and sent to the host. The host could then call returnGetStatus(status) to \"return\" the value via the argument. In this case, returnGetStatus(status) would be a function registered on the caller's side (Buzz) that uses the argument value as the \"return value\". Again the message is routed by the HiveMind to the Buzz script. This makes sure all messages are treated as events since function calls cannot directly return. This creates a system that is never blocking. An example of a host returning some payload in this manner is presented in the HiveMindBridge Reference section .","title":"HiveMind and the Swarm"},{"location":"sections/reference/HiveMind/hivemind-swarm/#hivemind-and-the-swarm","text":"The HiveMind makes uses of function calls as ways to interact with different components and those functions are called by name. As a user, you define the functions in the Buzz script or on the host and use them between the components. The functions are registered with a description of arguments (name and type) and a callback (the actual function). It is then possible to call this function from another component in the swarm. Those functions calls do not have return values, so instead it's possible to call another function and the \"return value\" will be an argument of the function call. For example: if the Buzz script calls getStatus() on its local host, the message is routed by the HiveMind and sent to the host. The host could then call returnGetStatus(status) to \"return\" the value via the argument. In this case, returnGetStatus(status) would be a function registered on the caller's side (Buzz) that uses the argument value as the \"return value\". Again the message is routed by the HiveMind to the Buzz script. This makes sure all messages are treated as events since function calls cannot directly return. This creates a system that is never blocking. An example of a host returning some payload in this manner is presented in the HiveMindBridge Reference section .","title":"HiveMind and the Swarm"},{"location":"sections/reference/HiveMindBridge/about-hivemindbridge/","text":"HiveMindBridge is a C++ library that provides an interface with the HiveMind API . It wraps many API calls and manages the acknowledgement of messages. The library works in an asynchronous manner, meaning that it supports making blocking calls without halting the execution flow of the program. HiveMindBridge was designed to work in a standalone manner , but can easily be interfaced with a ROS environment, like in these examples ( 1 ) ( 2 ). The codebase for HiveMindBridge is hosted on GitHub . The API documentation is hosted here .","title":"About HiveMindBridge"},{"location":"sections/reference/HiveMindBridge/defining-callbacks/","text":"Defining Callbacks Defining a callback should always be done by using the provided typedefs. The signature of the callback is the following: CallbackFunction myCallback = [ & ]( CallbackArgs args ) -> std :: optional < CallbackReturn > { } Notice how the function takes an argument of type CallbackArgs . This typedef is a vector of arguments. The arguments are wrapped in FunctionCallArgumentDTO objects, which can hold either int s or float s (this is implemented using std::variant ). The number of arguments is limited to 8. Tip The maximum number of arguments in a function call is set upon compilation of the propolis-pheromones library . The return value of the callbacks is always a type std::optional<CallbackReturn> . Why optional? Because some functions do not need to return any payload to the caller. In those cases, the user will simply return {} at the end of the function's body. When a function should return some payload, the data should be wrapped in a CallbackReturn object. Note The full API documentation for HiveMindBridge is hosted here . CallbackReturn objects CallbackReturn objects should be used to return some payload to the caller of a callback. When the payload is returned, it is wrapped in a function call request (aka a remote procedure call), and the payload is passed as arguments. This allows the callback to return the data in an asynchronous manner, so that the caller does not need to block its execution flow while waiting for the response. This further helps managing a swarm of robots where the agents might disconnect and reconnect randomly. For example, let's say we have registered a function getStatus() on the robot that returns two values of type int. The two values indicate arbitrary states for elements in the robot (e.g. is the Roboclaw controller ok, is a particular sensor working properly, etc.). CallbackFunction getStatus = [ & ]( CallbackArgs args ) -> std :: optional < CallbackReturn > { // Example values int64_t isRoboclawOk = 1 ; int64_t isSensorXOk = 0 ; CallbackArgs returnArgs ; returnArgs . push_back ( FunctionCallArgumentDTO ( isRoboclawOk )); // argument [0] returnArgs . push_back ( FunctionCallArgumentDTO ( isSensorXOk )); // argument [1] CallbackReturn cbReturn ( \"getStatusReturn\" , returnArgs ); return cbReturn ; }; When the data is returned, it is wrapped by HiveMindBridge in a function call request that will be sent to the original caller of the function. The user needs to provide the name of the function to call that will handle the return payload. In the example above, the returned data is sent to the caller by calling the getStatusReturn function. This function must be registered on the caller's side in order to process the reception of the return payload. Tip Notice how the return payload values are placed in a CallbackArgs object: this is because they will be passed to the getStatusReturn function as arguments. The arguments must be placed in a well-known order; that is, the order should match the one declared on the remote agent. Here is a summary of what happens : sequenceDiagram Remote Caller->>Robot: getStatus() Robot-)Remote Caller: getStatusReturn(isRoboclawOk, isSensorXOk) Tip When you implement you swarm solution, make sure to check that the return function calls are implemented on the remote caller, this will be a frequent cause of bugs. Remember: \"returning\" a value after the execution of a callback will really just make a function call request on the caller's side with the return values as arguments. Also, do make sure that the arguments match with the return values of the callback. Asynchronicity Callbacks are always run asynchronously (with the underlying use of std::async ). This allows the user to make blocking calls in the callbacks, without any impact on the rest of the execution flow. Do not hesitate to implement complex logic that takes lots of time to be processed in your callbacks: they were designed for that. CallbackFunction myCallback = [ & ]( CallbackArgs args ) -> std :: optional < CallbackReturn > { // some function logic... std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 2000 )); // This is perfectly fine, even in a callback! }","title":"Defining Callbacks"},{"location":"sections/reference/HiveMindBridge/defining-callbacks/#defining-callbacks","text":"Defining a callback should always be done by using the provided typedefs. The signature of the callback is the following: CallbackFunction myCallback = [ & ]( CallbackArgs args ) -> std :: optional < CallbackReturn > { } Notice how the function takes an argument of type CallbackArgs . This typedef is a vector of arguments. The arguments are wrapped in FunctionCallArgumentDTO objects, which can hold either int s or float s (this is implemented using std::variant ). The number of arguments is limited to 8. Tip The maximum number of arguments in a function call is set upon compilation of the propolis-pheromones library . The return value of the callbacks is always a type std::optional<CallbackReturn> . Why optional? Because some functions do not need to return any payload to the caller. In those cases, the user will simply return {} at the end of the function's body. When a function should return some payload, the data should be wrapped in a CallbackReturn object. Note The full API documentation for HiveMindBridge is hosted here .","title":"Defining Callbacks"},{"location":"sections/reference/HiveMindBridge/defining-callbacks/#callbackreturn-objects","text":"CallbackReturn objects should be used to return some payload to the caller of a callback. When the payload is returned, it is wrapped in a function call request (aka a remote procedure call), and the payload is passed as arguments. This allows the callback to return the data in an asynchronous manner, so that the caller does not need to block its execution flow while waiting for the response. This further helps managing a swarm of robots where the agents might disconnect and reconnect randomly. For example, let's say we have registered a function getStatus() on the robot that returns two values of type int. The two values indicate arbitrary states for elements in the robot (e.g. is the Roboclaw controller ok, is a particular sensor working properly, etc.). CallbackFunction getStatus = [ & ]( CallbackArgs args ) -> std :: optional < CallbackReturn > { // Example values int64_t isRoboclawOk = 1 ; int64_t isSensorXOk = 0 ; CallbackArgs returnArgs ; returnArgs . push_back ( FunctionCallArgumentDTO ( isRoboclawOk )); // argument [0] returnArgs . push_back ( FunctionCallArgumentDTO ( isSensorXOk )); // argument [1] CallbackReturn cbReturn ( \"getStatusReturn\" , returnArgs ); return cbReturn ; }; When the data is returned, it is wrapped by HiveMindBridge in a function call request that will be sent to the original caller of the function. The user needs to provide the name of the function to call that will handle the return payload. In the example above, the returned data is sent to the caller by calling the getStatusReturn function. This function must be registered on the caller's side in order to process the reception of the return payload. Tip Notice how the return payload values are placed in a CallbackArgs object: this is because they will be passed to the getStatusReturn function as arguments. The arguments must be placed in a well-known order; that is, the order should match the one declared on the remote agent. Here is a summary of what happens : sequenceDiagram Remote Caller->>Robot: getStatus() Robot-)Remote Caller: getStatusReturn(isRoboclawOk, isSensorXOk) Tip When you implement you swarm solution, make sure to check that the return function calls are implemented on the remote caller, this will be a frequent cause of bugs. Remember: \"returning\" a value after the execution of a callback will really just make a function call request on the caller's side with the return values as arguments. Also, do make sure that the arguments match with the return values of the callback.","title":"CallbackReturn objects"},{"location":"sections/reference/HiveMindBridge/defining-callbacks/#asynchronicity","text":"Callbacks are always run asynchronously (with the underlying use of std::async ). This allows the user to make blocking calls in the callbacks, without any impact on the rest of the execution flow. Do not hesitate to implement complex logic that takes lots of time to be processed in your callbacks: they were designed for that. CallbackFunction myCallback = [ & ]( CallbackArgs args ) -> std :: optional < CallbackReturn > { // some function logic... std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 2000 )); // This is perfectly fine, even in a callback! }","title":"Asynchronicity"},{"location":"sections/reference/HiveMindBridge/defining-manifests/","text":"Defining Manifests The manifest is a set of information that describes the different input arguments for each registered callback. Since the other swarm agents can ask a robot to list every function it can manage, there must be a way to describe the arguments that each function takes. This is the role of the manifest. The manifest is simply an vector of arguments and their name that is typedefed as CallbackArgsManifest . Note The full API documentation for HiveMindBridge is hosted here . Let's say we have a function moveBy that takes two aguments: float x and float y . Resigtering arguments in a manifest is done thusly: CallbackArgsManifest moveByManifest ; moveByManifest . push_back ( UserCallbackArgumentDescription ( \"x\" , FunctionDescriptionArgumentTypeDTO :: Float )); moveByManifest . push_back ( UserCallbackArgumentDescription ( \"y\" , FunctionDescriptionArgumentTypeDTO :: Float )); Attention The user must pay close attention to make sure that the order in which the arguments are registered in the manifest match the order of the arguments used in the corresponding callback function. Here, the callback expects that x is at position [0] and that y is at position [1] in the input arguments. Make sure to validate the order of the arguments across all the elements of the swarm when you debug.","title":"Defining Manifests"},{"location":"sections/reference/HiveMindBridge/defining-manifests/#defining-manifests","text":"The manifest is a set of information that describes the different input arguments for each registered callback. Since the other swarm agents can ask a robot to list every function it can manage, there must be a way to describe the arguments that each function takes. This is the role of the manifest. The manifest is simply an vector of arguments and their name that is typedefed as CallbackArgsManifest . Note The full API documentation for HiveMindBridge is hosted here . Let's say we have a function moveBy that takes two aguments: float x and float y . Resigtering arguments in a manifest is done thusly: CallbackArgsManifest moveByManifest ; moveByManifest . push_back ( UserCallbackArgumentDescription ( \"x\" , FunctionDescriptionArgumentTypeDTO :: Float )); moveByManifest . push_back ( UserCallbackArgumentDescription ( \"y\" , FunctionDescriptionArgumentTypeDTO :: Float )); Attention The user must pay close attention to make sure that the order in which the arguments are registered in the manifest match the order of the arguments used in the corresponding callback function. Here, the callback expects that x is at position [0] and that y is at position [1] in the input arguments. Make sure to validate the order of the arguments across all the elements of the swarm when you debug.","title":"Defining Manifests"},{"location":"sections/reference/HiveMindBridge/logger/","text":"A basic logger The following listing is an example of a logger that can be injected upon constructing a HiveMindBridge object. This implementation simply wraps the ROS logger. Feel free to use this as a base and modify it for your needs. Depending on your implementation needs, you might want to use other logging techniques that do not depend on ROS. #include \"ros/ros.h\" #include <cpp-common/ILogger.h> #include <cstdarg> class Logger : public ILogger { public : Logger () {} LogRet log ( LogLevel level , const char * format , ...) override { va_list args ; va_start ( args , format ); int retVal = formatAndAppend ( format , args ); va_end ( args ); flush ( level ); if ( retVal >= 0 ) { return LogRet :: Ok ; } else { return LogRet :: Error ; } } int formatAndAppend ( const char * format , va_list args ) { // Copy varargs va_list vaCopy ; va_copy ( vaCopy , args ); const int requiredLength = std :: vsnprintf ( NULL , 0 , format , vaCopy ); va_end ( vaCopy ); // Create a string with adequate length std :: string tmpStr ; tmpStr . resize (( size_t ) requiredLength ); // Build a new string int retValue = vsnprintf ( tmpStr . data (), tmpStr . size () + 1 , format , args ); m_accumulatedString = m_accumulatedString + tmpStr ; return retValue ; } void flush ( LogLevel level ) { switch ( level ) { case LogLevel :: Debug : ROS_DEBUG ( \"%s\" , m_accumulatedString . c_str ()); break ; case LogLevel :: Info : ROS_INFO ( \"%s\" , m_accumulatedString . c_str ()); break ; case LogLevel :: Warn : ROS_WARN ( \"%s\" , m_accumulatedString . c_str ()); break ; case LogLevel :: Error : ROS_ERROR ( \"%s\" , m_accumulatedString . c_str ()); break ; } m_accumulatedString = \"\" ; } private : std :: string m_accumulatedString ; };","title":"Example Logger Implementation"},{"location":"sections/reference/HiveMindBridge/logger/#a-basic-logger","text":"The following listing is an example of a logger that can be injected upon constructing a HiveMindBridge object. This implementation simply wraps the ROS logger. Feel free to use this as a base and modify it for your needs. Depending on your implementation needs, you might want to use other logging techniques that do not depend on ROS. #include \"ros/ros.h\" #include <cpp-common/ILogger.h> #include <cstdarg> class Logger : public ILogger { public : Logger () {} LogRet log ( LogLevel level , const char * format , ...) override { va_list args ; va_start ( args , format ); int retVal = formatAndAppend ( format , args ); va_end ( args ); flush ( level ); if ( retVal >= 0 ) { return LogRet :: Ok ; } else { return LogRet :: Error ; } } int formatAndAppend ( const char * format , va_list args ) { // Copy varargs va_list vaCopy ; va_copy ( vaCopy , args ); const int requiredLength = std :: vsnprintf ( NULL , 0 , format , vaCopy ); va_end ( vaCopy ); // Create a string with adequate length std :: string tmpStr ; tmpStr . resize (( size_t ) requiredLength ); // Build a new string int retValue = vsnprintf ( tmpStr . data (), tmpStr . size () + 1 , format , args ); m_accumulatedString = m_accumulatedString + tmpStr ; return retValue ; } void flush ( LogLevel level ) { switch ( level ) { case LogLevel :: Debug : ROS_DEBUG ( \"%s\" , m_accumulatedString . c_str ()); break ; case LogLevel :: Info : ROS_INFO ( \"%s\" , m_accumulatedString . c_str ()); break ; case LogLevel :: Warn : ROS_WARN ( \"%s\" , m_accumulatedString . c_str ()); break ; case LogLevel :: Error : ROS_ERROR ( \"%s\" , m_accumulatedString . c_str ()); break ; } m_accumulatedString = \"\" ; } private : std :: string m_accumulatedString ; };","title":"A basic logger"},{"location":"sections/reference/HiveMindBridge/registering-custom-actions/","text":"Registering Custom Actions Registering custom actions is always done by following three steps: Define the callback that describes the behaviour of the custom action (see Defining Callbacks ). Define the manifest that describes the input arguments of the callback (see Defining Manifests . This is optional, as some callbacks will not require any input arguments) Register the custom action in the HiveMindBridge object. This page explains the registration of the custom action in the HiveMindBridge object. Note The full API documentation for HiveMindBridge is hosted here . Custom Actions Are Discoverable Swarm agents can discover the capabilities of the other agents by querying the list of their registered functions. To ensure the discoverability of a robot's function, users must define a manifest and register the callback in the HiveMindBridge object. The registration of custom actions is the process of associating the function's name with a function pointer and a manifest. Let's say we have a moveBy(float x, float y) function: CallbackArgsManifest moveByManifest ; moveByManifest . push_back ( UserCallbackArgumentDescription ( \"x\" , FunctionDescriptionArgumentTypeDTO :: Float )); moveByManifest . push_back ( UserCallbackArgumentDescription ( \"y\" , FunctionDescriptionArgumentTypeDTO :: Float )); bridge . registerCustomAction ( \"moveBy\" , moveByCallback , moveByManifest ); The last line shows the association between the name, the function pointer, and the manifest. The registration also allows HiveMindBridge to handle the incoming function call requests.","title":"Registering Custom Actions"},{"location":"sections/reference/HiveMindBridge/registering-custom-actions/#registering-custom-actions","text":"Registering custom actions is always done by following three steps: Define the callback that describes the behaviour of the custom action (see Defining Callbacks ). Define the manifest that describes the input arguments of the callback (see Defining Manifests . This is optional, as some callbacks will not require any input arguments) Register the custom action in the HiveMindBridge object. This page explains the registration of the custom action in the HiveMindBridge object. Note The full API documentation for HiveMindBridge is hosted here .","title":"Registering Custom Actions"},{"location":"sections/reference/HiveMindBridge/registering-custom-actions/#custom-actions-are-discoverable","text":"Swarm agents can discover the capabilities of the other agents by querying the list of their registered functions. To ensure the discoverability of a robot's function, users must define a manifest and register the callback in the HiveMindBridge object. The registration of custom actions is the process of associating the function's name with a function pointer and a manifest. Let's say we have a moveBy(float x, float y) function: CallbackArgsManifest moveByManifest ; moveByManifest . push_back ( UserCallbackArgumentDescription ( \"x\" , FunctionDescriptionArgumentTypeDTO :: Float )); moveByManifest . push_back ( UserCallbackArgumentDescription ( \"y\" , FunctionDescriptionArgumentTypeDTO :: Float )); bridge . registerCustomAction ( \"moveBy\" , moveByCallback , moveByManifest ); The last line shows the association between the name, the function pointer, and the manifest. The registration also allows HiveMindBridge to handle the incoming function call requests.","title":"Custom Actions Are Discoverable"},{"location":"sections/reference/Interloc/calibrating_a_hiveboard/","text":"Interlocalisation - Calibration The interlocalisation system is very sensitive to any hardware changes. For this reason, the BeeBoard assembly should be calibrated in order to know exactly the system behavior and to correctly map the different measured parameters and the output angle, this, for one precise assembly . Objective As explained in how the angle is calculated , what is called the angle cannot be directly obtained from the values extracted from the DW1000 chips. In fact, there is no one-to-one correspondence as there are many angle possiblities. To allow this correspondence a transformation has to be made on the angle measured from the PDOA values. The transformation is made from the following graph : These values are obtained from the extractRawData and Parser scripts using the test-bench TurningStation . Note Please refer to these scripts official documentation for a step-by-step description on the procedure to follow to acquire this kind of data. Note that the theoretical values should follow the following trends : As there is a considerable difference between the real and theoretical values, the real data has to be characterized, theoretical values will not give a proper rendition of the reality. This characterization will permit the interlocalisation algortihm to compute actual angles from PDOA values. The theoretical values show a correspondence made of two linear slopes, one falling and one rising which repete themselves at each full turn. The calibration procedure will permit the extraction of these slopes for each antenna pair. Procedure The complete procedure on how to perform a calibration and how to validate the results is found here . Follow the flow chart to execute each scripts in the right order. After the final validation step is successful, the assembly is ready to be mounted on its final destination, and the interlocalisation system should be operationnal. Caution The assembly is described as : - The BeeBoard mount - The 3 wings boards - The 3 USC-C cables - The HiveBoard - The channel used for each BeeBoard. If any of these is changed, or connected differently from the original calibration, the calibration must be re-done. Do not forget to re-write the parameters in the flash using Send_angle_params","title":"Calibrating a Hiveboard"},{"location":"sections/reference/Interloc/calibrating_a_hiveboard/#interlocalisation-calibration","text":"The interlocalisation system is very sensitive to any hardware changes. For this reason, the BeeBoard assembly should be calibrated in order to know exactly the system behavior and to correctly map the different measured parameters and the output angle, this, for one precise assembly .","title":"Interlocalisation - Calibration"},{"location":"sections/reference/Interloc/calibrating_a_hiveboard/#objective","text":"As explained in how the angle is calculated , what is called the angle cannot be directly obtained from the values extracted from the DW1000 chips. In fact, there is no one-to-one correspondence as there are many angle possiblities. To allow this correspondence a transformation has to be made on the angle measured from the PDOA values. The transformation is made from the following graph : These values are obtained from the extractRawData and Parser scripts using the test-bench TurningStation . Note Please refer to these scripts official documentation for a step-by-step description on the procedure to follow to acquire this kind of data. Note that the theoretical values should follow the following trends : As there is a considerable difference between the real and theoretical values, the real data has to be characterized, theoretical values will not give a proper rendition of the reality. This characterization will permit the interlocalisation algortihm to compute actual angles from PDOA values. The theoretical values show a correspondence made of two linear slopes, one falling and one rising which repete themselves at each full turn. The calibration procedure will permit the extraction of these slopes for each antenna pair.","title":"Objective"},{"location":"sections/reference/Interloc/calibrating_a_hiveboard/#procedure","text":"The complete procedure on how to perform a calibration and how to validate the results is found here . Follow the flow chart to execute each scripts in the right order. After the final validation step is successful, the assembly is ready to be mounted on its final destination, and the interlocalisation system should be operationnal. Caution The assembly is described as : - The BeeBoard mount - The 3 wings boards - The 3 USC-C cables - The HiveBoard - The channel used for each BeeBoard. If any of these is changed, or connected differently from the original calibration, the calibration must be re-done. Do not forget to re-write the parameters in the flash using Send_angle_params","title":"Procedure"},{"location":"sections/reference/Interloc/how_it_works/angle/","text":"Angle Measurement Theory Before explaining how angle measurement is done in the HiveMind, lets take a few steps back and see some of the theoretical fundametals (in a 2-antenna scenario) used in the calculation. Because antennas in the system are so close to each other (2.7 cm), it is not possible to rely solely on timestamping messages received at different antennas to evaluate an angle. At 2.7 cm (the maximum time difference), radio waves only take 90 ps to travel. The DW1000 can timestamp with a 15 ps accuracy. When accounting for noise we can see that the time difference will be almost no use to estimate an angle with certainty. The solution is to calculate a phase difference ( \\(\\alpha\\) ) instead of a time difference. The antennas are placed at less then a wavelength (3.5 cm) appart. This way, the radio wave will hit each antenna at a different moment all while staying within the same period (because a period spans a distance of \\(\\lambda/2\\) ). Phase Difference Knowing the phase difference and doing a little trigonometry, the angle of arrival (AoA) can be calculated: $$ \\theta = arcsin\\left(\\frac{\\alpha}{\\pi}\\right) $$ Calculating \\(\\alpha\\) can be done by using registers found in the DW1000. The user is refered to the DW1000 User Manual and an article published by DecaWave on the subject. \\[ \\alpha = \\left(\\left( \\phi_A - \\beta_A - \\phi_B + \\beta_B + \\pi \\right) mod 2\\pi \\right) - \\pi \\] Where \\(\\phi\\) is the synchronization frame delimiter (SFD) angle and \\(\\beta\\) is the first path (FP) angle. The \\(arcsin()\\) in the equation allows a one-to-one linear mapping of phase differences from \\(-\\pi/2\\) to \\(\\pi/2\\) to angles going from \\(-\\pi/2\\) to \\(\\pi/2\\) . To bring the mapping to angles between \\(0\\) and \\(\\pi\\) , an offset is added to the equation presented earlier: $$ \\alpha = \\left(\\left( \\phi_A - \\beta_A - \\phi_B + \\beta_B - \\frac{\\pi}{2} \\right) mod 2\\pi \\right) - \\pi $$ The problem with this approach is that a one-to-one mapping is only available from \\(-\\pi/2\\) to \\(\\pi/2\\) (or \\(\\pi/2\\) to \\(3\\pi/2\\) in the following figure). For the second half of the circle, the same values come back, only mirrored, making it impossible to determine what the actual angle is. Angle measurement with a single antenna pair Expanding Beyond 180\u00b0 To be able to measure the angle of arrival on the whole unit circle, three antennas must be used. By placing antennas in an equilateral triangle, we can calculate the AoA for each of the three antenna pairs which will all be offset by 60\u00b0 Angle measurement with multiple antenna pairs The problem of knowing which mapping (the downwards or upwards slope) to use for each pair is still present. However, by using information from the two other pairs, it is possible to know which slope to choose. By placing imaginary lines at +/- 30\u00b0, we can use the AoA value of another antenna pair to know which slope to use for the current pair. Note Don't forget the x-axis is the real angle. So what we are measuring is a point on the y-axis to which we are trying to map a point on the x-axis. Choosing the correct slope For example, take pair 1. The rising slope should be chosen when pair 2 or pair 3 is below the -30\u00b0 line while the falling slope should be chosen when pair 2 or pair 3 is above the +30\u00b0 line. At any given angle, only one curve can be measured between the two lines. This gives a way to know with certainty (in theory) which slope to use for all three of the pairs. By applying the correct slope, the real angle can be calculated. In an ideal scenario, calculating the angle for each of the three pairs will yield the same result. Implementation & Certainty Real World Data Of course, when taking into acount the real world and noise, the data is not as clean as presented earlier, making it a little harder to calculate an angle. The first thing we notice is that all the curves are offset from their theoretical value by a certain amount. Offset in PDoA data The good news is that this offset is constant. It is due to the clock skew (difference in travel length) present in the system. This skew does not change unless a component in the system (cable, BeeBoard, etc.) is changed. This is why a per-system calibration is done. After applying a correction for the offset, the data does start to look like the theoretical model presented earlier. Offset correction Note You may notice that some of the data points tend to wrap around (the effect is pretty obvious at 0\u00b0 and 100\u00b0). This is the main cause of errors in the system as having data on the wrong side of the +/- 30\u00b0 line makes us choose the wrong slope to fit the data. In order to reduce such wrapping, the antennas could be brought even closer together (they are curently at 2.7 cm apart). The equation to calculate the phase difference ( \\(\\alpha\\) ) must be changed to take this offset ( \\(z\\) ) into account: $$ \\alpha_{corrected} = \\left(\\left( \\phi_A - \\beta_A - \\phi_B + \\beta_B - \\frac{\\pi}{2} + z \\right) mod 2\\pi \\right) - \\pi $$ Each antenna pair is then modeled with two linear equations of the form \\(y = ax + b\\) with one positive and one negative slope. Even for curves where three slopes are visible (for example the purple curve), only two slopes are needed as the third one is the prolongation of the first one modulo 360\u00b0. Calculating a Single Angle In the previous section , we mentioned that the algorithm would return the same angle for any of the three antenna pairs. Although the real world data is close to theory, it is not perfect and each antenna pair will yield a different angle. Actually, it might even yield an angle pretty far from reality if the wrong slope is chosen because of the +/- 30\u00b0 decision zone. Because of this, a choice was made to have the algorithm produce six different angle possibilties (two for each antenna pair) as well as a certainty estimation for each possibility. A weighted average of the results then produces a single angle value. Note The certainty calculation was made as a way to facilitate the integration of the angle measurement in a Kalman filter. All six results don't go up through the whole software stack, but they are accessible in the file src/bsp/src/stm32/src/interloc/src/AngleCalculator.cpp if such a filter is to be implemented. The certainty calculation is made throughout the algorithm multiplying certainties at each step as a way to have multiple factors taken into account. Let's go trough the algorithm step by step and explain what is done in each of them. 1. Calculate \\(\\theta\\) for every antenna pair. Activate all three DW1000s in RX mode and receive the same message on the three antennas (see synchronization for more information). Extract the data from the registers of each DW1000 and compute \\(\\alpha\\) and \\(\\theta\\) . $$ \\alpha_{corrected} = \\left(\\left( \\phi_A - \\beta_A - \\phi_B + \\beta_B - \\frac{\\pi}{2} + z \\right) mod 2\\pi \\right) - \\pi $$ $$ \\theta = arcsin\\left(\\frac{\\alpha_{corrected}}{\\pi}\\right) $$ \\(\\theta\\) gives us a point on the y-axis of the previous graphs. In order to reduce the standard deviation of the data, multiple (currently 10) messages are received and the mean of all \\(\\theta\\) s of the same antenna pair is taken as the actual \\(\\theta\\) . 2. Compute \\(\\theta\\) certainty Because the spread of data is larger for \\(\\theta\\) values nearing +/- 90\u00b0 and this is where wrap-arounds happen, the certainty for each \\(\\theta\\) value is calculated according to the following curve: Certainty of \u03b8 value Following this, we have three values of \\(\\theta\\) each with their certainty. 3. Compute slope certainty The next step is to choose which slope to use for each antenna pair according to the +/- 30\u00b0 decision line. This is done using what was called the decision matrix. The matrix tells us what slope to choose if another antenna pair has a \\(\\theta\\) value above the 30\u00b0 decision line. Decision Matrix Note Antenna pairs were chosen to match the graphs above. In total, there are six pairs with pairs 3, 4, 5 being the inverse of pairs 0, 1, 2 For example, for antenna pair 0 (first line), if antenna pair 1 (second column) has a \\(\\theta\\) value greater than 30\u00b0, the falling slope should be chosen. On the other hand if antenna pair 5 (third column) has a \\(\\theta\\) value greater than 30\u00b0 it is the rising slope that should be used. The inverse matrix also exists telling us the slope to choose if the other pairs have values under the -30\u00b0 decision line. A certainty of being above or below 30\u00b0 is therefore computed for each antenna pair. Certainty of decision line The certainty is multiplied with the certainty of the \\(\\theta\\) value previously calculated. The certainty of each slope for each antenna pair is computed using the decision matrix. For example if calculating slope certainties for pair 0, if we have \\(\\theta_1 = 60\u00b0\\) and \\(\\theta_5 = 25\u00b0\\) , the certainties of being above the 30\u00b0 line would be around 1 and 0.3 while the certainties of being below the line are both 0. The decision matrix tells us that \\(\\theta_1 > 30\u00b0\\) means a falling slope and \\(\\theta_5 > 30\u00b0\\) means a rising slope. We would then have the certainty of choosing the falling slope being 1 and the certainty of choosing the rising slope being 0.3. Of course this is a pretty drastic example, normally both values tend to agree on the same slope. (When there are two certainties of choosing the same slope, the maximum of both values is taken) This operation is done for every antenna pair giving us rising and falling slope certainties for each of the three pairs. 4. Apply the linear fit For each pair, both linear fits (rising and falling) are applied using the reciprocal function (because we are trying to map a calculated angle (y-axis) to a real angle (x-axis)): $$ Angle = (\\theta - b) / a $$ The certainty value of the angle is the certainty of the slope multiplied by the certainty of the \\(\\theta\\) value. This gives us six different angle and certainty values. 5. Reduce everything down to a single result In order to return a single angle, a small algorithm checks if two values in the six are within a margin of error of each other. If this is the case, there is a good chance that those values are the actual angle and a weighted average of the two angles with their certainties is done. If no values are close of each other or if all values fall within a certain margin of each other, a weighted average of all six values and their certainties is done.","title":"Angle Measurement"},{"location":"sections/reference/Interloc/how_it_works/angle/#angle-measurement","text":"","title":"Angle Measurement"},{"location":"sections/reference/Interloc/how_it_works/angle/#theory","text":"Before explaining how angle measurement is done in the HiveMind, lets take a few steps back and see some of the theoretical fundametals (in a 2-antenna scenario) used in the calculation. Because antennas in the system are so close to each other (2.7 cm), it is not possible to rely solely on timestamping messages received at different antennas to evaluate an angle. At 2.7 cm (the maximum time difference), radio waves only take 90 ps to travel. The DW1000 can timestamp with a 15 ps accuracy. When accounting for noise we can see that the time difference will be almost no use to estimate an angle with certainty. The solution is to calculate a phase difference ( \\(\\alpha\\) ) instead of a time difference. The antennas are placed at less then a wavelength (3.5 cm) appart. This way, the radio wave will hit each antenna at a different moment all while staying within the same period (because a period spans a distance of \\(\\lambda/2\\) ). Phase Difference Knowing the phase difference and doing a little trigonometry, the angle of arrival (AoA) can be calculated: $$ \\theta = arcsin\\left(\\frac{\\alpha}{\\pi}\\right) $$ Calculating \\(\\alpha\\) can be done by using registers found in the DW1000. The user is refered to the DW1000 User Manual and an article published by DecaWave on the subject. \\[ \\alpha = \\left(\\left( \\phi_A - \\beta_A - \\phi_B + \\beta_B + \\pi \\right) mod 2\\pi \\right) - \\pi \\] Where \\(\\phi\\) is the synchronization frame delimiter (SFD) angle and \\(\\beta\\) is the first path (FP) angle. The \\(arcsin()\\) in the equation allows a one-to-one linear mapping of phase differences from \\(-\\pi/2\\) to \\(\\pi/2\\) to angles going from \\(-\\pi/2\\) to \\(\\pi/2\\) . To bring the mapping to angles between \\(0\\) and \\(\\pi\\) , an offset is added to the equation presented earlier: $$ \\alpha = \\left(\\left( \\phi_A - \\beta_A - \\phi_B + \\beta_B - \\frac{\\pi}{2} \\right) mod 2\\pi \\right) - \\pi $$ The problem with this approach is that a one-to-one mapping is only available from \\(-\\pi/2\\) to \\(\\pi/2\\) (or \\(\\pi/2\\) to \\(3\\pi/2\\) in the following figure). For the second half of the circle, the same values come back, only mirrored, making it impossible to determine what the actual angle is. Angle measurement with a single antenna pair","title":"Theory"},{"location":"sections/reference/Interloc/how_it_works/angle/#expanding-beyond-180","text":"To be able to measure the angle of arrival on the whole unit circle, three antennas must be used. By placing antennas in an equilateral triangle, we can calculate the AoA for each of the three antenna pairs which will all be offset by 60\u00b0 Angle measurement with multiple antenna pairs The problem of knowing which mapping (the downwards or upwards slope) to use for each pair is still present. However, by using information from the two other pairs, it is possible to know which slope to choose. By placing imaginary lines at +/- 30\u00b0, we can use the AoA value of another antenna pair to know which slope to use for the current pair. Note Don't forget the x-axis is the real angle. So what we are measuring is a point on the y-axis to which we are trying to map a point on the x-axis. Choosing the correct slope For example, take pair 1. The rising slope should be chosen when pair 2 or pair 3 is below the -30\u00b0 line while the falling slope should be chosen when pair 2 or pair 3 is above the +30\u00b0 line. At any given angle, only one curve can be measured between the two lines. This gives a way to know with certainty (in theory) which slope to use for all three of the pairs. By applying the correct slope, the real angle can be calculated. In an ideal scenario, calculating the angle for each of the three pairs will yield the same result.","title":"Expanding Beyond 180\u00b0"},{"location":"sections/reference/Interloc/how_it_works/angle/#implementation-certainty","text":"","title":"Implementation &amp; Certainty"},{"location":"sections/reference/Interloc/how_it_works/angle/#real-world-data","text":"Of course, when taking into acount the real world and noise, the data is not as clean as presented earlier, making it a little harder to calculate an angle. The first thing we notice is that all the curves are offset from their theoretical value by a certain amount. Offset in PDoA data The good news is that this offset is constant. It is due to the clock skew (difference in travel length) present in the system. This skew does not change unless a component in the system (cable, BeeBoard, etc.) is changed. This is why a per-system calibration is done. After applying a correction for the offset, the data does start to look like the theoretical model presented earlier. Offset correction Note You may notice that some of the data points tend to wrap around (the effect is pretty obvious at 0\u00b0 and 100\u00b0). This is the main cause of errors in the system as having data on the wrong side of the +/- 30\u00b0 line makes us choose the wrong slope to fit the data. In order to reduce such wrapping, the antennas could be brought even closer together (they are curently at 2.7 cm apart). The equation to calculate the phase difference ( \\(\\alpha\\) ) must be changed to take this offset ( \\(z\\) ) into account: $$ \\alpha_{corrected} = \\left(\\left( \\phi_A - \\beta_A - \\phi_B + \\beta_B - \\frac{\\pi}{2} + z \\right) mod 2\\pi \\right) - \\pi $$ Each antenna pair is then modeled with two linear equations of the form \\(y = ax + b\\) with one positive and one negative slope. Even for curves where three slopes are visible (for example the purple curve), only two slopes are needed as the third one is the prolongation of the first one modulo 360\u00b0.","title":"Real World Data"},{"location":"sections/reference/Interloc/how_it_works/angle/#calculating-a-single-angle","text":"In the previous section , we mentioned that the algorithm would return the same angle for any of the three antenna pairs. Although the real world data is close to theory, it is not perfect and each antenna pair will yield a different angle. Actually, it might even yield an angle pretty far from reality if the wrong slope is chosen because of the +/- 30\u00b0 decision zone. Because of this, a choice was made to have the algorithm produce six different angle possibilties (two for each antenna pair) as well as a certainty estimation for each possibility. A weighted average of the results then produces a single angle value. Note The certainty calculation was made as a way to facilitate the integration of the angle measurement in a Kalman filter. All six results don't go up through the whole software stack, but they are accessible in the file src/bsp/src/stm32/src/interloc/src/AngleCalculator.cpp if such a filter is to be implemented. The certainty calculation is made throughout the algorithm multiplying certainties at each step as a way to have multiple factors taken into account. Let's go trough the algorithm step by step and explain what is done in each of them. 1. Calculate \\(\\theta\\) for every antenna pair. Activate all three DW1000s in RX mode and receive the same message on the three antennas (see synchronization for more information). Extract the data from the registers of each DW1000 and compute \\(\\alpha\\) and \\(\\theta\\) . $$ \\alpha_{corrected} = \\left(\\left( \\phi_A - \\beta_A - \\phi_B + \\beta_B - \\frac{\\pi}{2} + z \\right) mod 2\\pi \\right) - \\pi $$ $$ \\theta = arcsin\\left(\\frac{\\alpha_{corrected}}{\\pi}\\right) $$ \\(\\theta\\) gives us a point on the y-axis of the previous graphs. In order to reduce the standard deviation of the data, multiple (currently 10) messages are received and the mean of all \\(\\theta\\) s of the same antenna pair is taken as the actual \\(\\theta\\) . 2. Compute \\(\\theta\\) certainty Because the spread of data is larger for \\(\\theta\\) values nearing +/- 90\u00b0 and this is where wrap-arounds happen, the certainty for each \\(\\theta\\) value is calculated according to the following curve: Certainty of \u03b8 value Following this, we have three values of \\(\\theta\\) each with their certainty. 3. Compute slope certainty The next step is to choose which slope to use for each antenna pair according to the +/- 30\u00b0 decision line. This is done using what was called the decision matrix. The matrix tells us what slope to choose if another antenna pair has a \\(\\theta\\) value above the 30\u00b0 decision line. Decision Matrix Note Antenna pairs were chosen to match the graphs above. In total, there are six pairs with pairs 3, 4, 5 being the inverse of pairs 0, 1, 2 For example, for antenna pair 0 (first line), if antenna pair 1 (second column) has a \\(\\theta\\) value greater than 30\u00b0, the falling slope should be chosen. On the other hand if antenna pair 5 (third column) has a \\(\\theta\\) value greater than 30\u00b0 it is the rising slope that should be used. The inverse matrix also exists telling us the slope to choose if the other pairs have values under the -30\u00b0 decision line. A certainty of being above or below 30\u00b0 is therefore computed for each antenna pair. Certainty of decision line The certainty is multiplied with the certainty of the \\(\\theta\\) value previously calculated. The certainty of each slope for each antenna pair is computed using the decision matrix. For example if calculating slope certainties for pair 0, if we have \\(\\theta_1 = 60\u00b0\\) and \\(\\theta_5 = 25\u00b0\\) , the certainties of being above the 30\u00b0 line would be around 1 and 0.3 while the certainties of being below the line are both 0. The decision matrix tells us that \\(\\theta_1 > 30\u00b0\\) means a falling slope and \\(\\theta_5 > 30\u00b0\\) means a rising slope. We would then have the certainty of choosing the falling slope being 1 and the certainty of choosing the rising slope being 0.3. Of course this is a pretty drastic example, normally both values tend to agree on the same slope. (When there are two certainties of choosing the same slope, the maximum of both values is taken) This operation is done for every antenna pair giving us rising and falling slope certainties for each of the three pairs. 4. Apply the linear fit For each pair, both linear fits (rising and falling) are applied using the reciprocal function (because we are trying to map a calculated angle (y-axis) to a real angle (x-axis)): $$ Angle = (\\theta - b) / a $$ The certainty value of the angle is the certainty of the slope multiplied by the certainty of the \\(\\theta\\) value. This gives us six different angle and certainty values. 5. Reduce everything down to a single result In order to return a single angle, a small algorithm checks if two values in the six are within a margin of error of each other. If this is the case, there is a good chance that those values are the actual angle and a weighted average of the two angles with their certainties is done. If no values are close of each other or if all values fall within a certain margin of each other, a weighted average of all six values and their certainties is done.","title":"Calculating a Single Angle"},{"location":"sections/reference/Interloc/how_it_works/distance/","text":"Distance Measurement Distance measurement is done using the two-way ranging algorithm as described in the DW1000 User Manual (Appendix 3) . The following section is meant as a quick reference in order to understand the need for all messages sent in the system and how they are organized using the synchronization state machine . Two-Way Ranging Algorithm In short, the two-way ranging (TWR) algorithm works by timing how long a message takes to travel from one antenna to the other. Knowing the speed of light, a distance measurement can then be derived. In order to understand how TWR works, one must know the following features of UWB communication with the DW1000 heavily used in the algorithm: UWB packets are sent using very time constrained pulses. This allows precisely timestamping received messages as well as differentiate the first path (line of sight) signal from other signals when the radio waves bounce around walls or other obstacles. The DW1000 can also timestamp when messages are transmitted and even send messages at a specific timestamp. Messages are always timestamped at the same place, called the RMARKER at the beginning of a transmission. This way, the length of a message has no impact on the ability to timestamp it. Note Timestamps on the DW1000 can be quite tricky to understand as RX and TX timestamps are not created exactly at the same moment and the antenna delay must be taken into account. Before tweaking anything in the algorithm, the user should read sections 3.2, 3.3 and 4.1.6 of the DW1000 User Manual . One-to-One TWR could be done using as few as two messages. However, in order the minimize the error induced by the difference in clock frequency between HiveBoards, a three-message scheme known as Asymmetric Double-Sided Two-Way Ranging is used. This scheme is based around two devices (the Initiator and the Responder) as well as three messages (Poll, Response and Final). The Initiator starts by sending the Poll message at a given time ( poll_tx_ts ). The Responder receives the message and timestamps it ( poll_rx_ts ). The Responder sends the Response message back to the Initator at time ( resp_tx_ts ). The Initiator timestamps the message ( resp_rx_ts ). The Initiator decides a timestamp at which to send the Final message and starts a delay send operation. This allows to insert the timestamp at which the message will be sent ( final_tx_ts ) inside the message itself. The Final message is the only one containing a useful payload comprised of all timestamps the Initiator knows: poll_tx_ts resp_rx_ts final_tx_ts Upon reception of the Final message, the responder then has all six timestamps (RX and TX for three messages) in hand allowing it to calculate the average time of flight (ToF) of messages using the following figure and equations. Asymmetric Double-Sided Two-Way Ranging \\[ ToF = \\frac{T_{round1} \\cdot T_{round2} - T_{reply1} \\cdot T_{reply2}}{T_{round1} + T_{round2} + T_{reply1} + T_{reply2}} \\] Where $$ T_{round1} = resp\\_rx\\_ts - poll\\_tx\\_ts $$ \\[ T_{round2} = final\\_rx\\_ts - resp\\_tx\\_ts \\] \\[ T_{reply1} = resp\\_tx\\_ts - poll\\_rx\\_ts \\] \\[ T_{reply2} = final\\_tx\\_ts - resp\\_rx\\_ts \\] After performing the calculation, the Responder then knows the distance seperating it from the Initiator. (The inverse is not true. The Initiator does not have all timestamps required to calculate the distance). One-to-Many The drawback of the one-to-one algorithm is that, in a multi-agent scenario, three messages must be sent for each agent to know their distance to a single other robot. The number of messages for every agent to know its distance from every other agent grows factorially thus decreasing the refresh rate of the whole system. Instead of having every agent perform a 1:1 TWR with every other agent, the scheme presented previously is extended to allow multiple Responders. Instead of having one Initiator and one Responder, we have one Initiator and \\(N-1\\) Responders (every agent except for the Initiator). The message exchange is then very similar to the 1:1 scenario: The initiator sends the Init message which is received by all Responders simultaneously. Each Responder, in turns, sends the Response message. The Initiator receives all the messages and timestamps them all. The Initiator sends the final message now containing \\(N\\) response_rx_ts, one for each Responder. Each Responder then has the six timestamps needed to compute their distance from the Initiator. After \\(2 + N\\) messages, all the agents, other than the Initiator, have updated their distance from the Initiator. Each agent then takes turns becoming the Initiator every time allowing all other agents to update their position from the Initiator. The sequence is summarized in the following figure. Multi-agent Two Way Ranging implementation More details on this time-slotting mechanism can be found in the synchronisation page . Further Reading The following application notes produced by Decawave can help understanding the algorithm used in the SwarmUS platform. They also contain some knowledge about different algorithms that could be implemented as well as corrections for non line-of-sight operation and calibrations in order to achieve maximum accuracy. Application Note APS006 - Part 1 Channel Effects on Range Accuracy Application Note APS006 - Part 2 NLOS Operation and Optimizations Application Note APS006 - Part 3 DW1000 Diagnostics for NLOS Channels Application Note APS011 - Sources of Error in Two Way Ranging Application Note APS013 - The Implementation of Two-Way Ranging with he DW1000 Application Note APS014 - Antennna Delay Calibration","title":"Distance Measurement"},{"location":"sections/reference/Interloc/how_it_works/distance/#distance-measurement","text":"Distance measurement is done using the two-way ranging algorithm as described in the DW1000 User Manual (Appendix 3) . The following section is meant as a quick reference in order to understand the need for all messages sent in the system and how they are organized using the synchronization state machine .","title":"Distance Measurement"},{"location":"sections/reference/Interloc/how_it_works/distance/#two-way-ranging-algorithm","text":"In short, the two-way ranging (TWR) algorithm works by timing how long a message takes to travel from one antenna to the other. Knowing the speed of light, a distance measurement can then be derived. In order to understand how TWR works, one must know the following features of UWB communication with the DW1000 heavily used in the algorithm: UWB packets are sent using very time constrained pulses. This allows precisely timestamping received messages as well as differentiate the first path (line of sight) signal from other signals when the radio waves bounce around walls or other obstacles. The DW1000 can also timestamp when messages are transmitted and even send messages at a specific timestamp. Messages are always timestamped at the same place, called the RMARKER at the beginning of a transmission. This way, the length of a message has no impact on the ability to timestamp it. Note Timestamps on the DW1000 can be quite tricky to understand as RX and TX timestamps are not created exactly at the same moment and the antenna delay must be taken into account. Before tweaking anything in the algorithm, the user should read sections 3.2, 3.3 and 4.1.6 of the DW1000 User Manual .","title":"Two-Way Ranging Algorithm"},{"location":"sections/reference/Interloc/how_it_works/distance/#one-to-one","text":"TWR could be done using as few as two messages. However, in order the minimize the error induced by the difference in clock frequency between HiveBoards, a three-message scheme known as Asymmetric Double-Sided Two-Way Ranging is used. This scheme is based around two devices (the Initiator and the Responder) as well as three messages (Poll, Response and Final). The Initiator starts by sending the Poll message at a given time ( poll_tx_ts ). The Responder receives the message and timestamps it ( poll_rx_ts ). The Responder sends the Response message back to the Initator at time ( resp_tx_ts ). The Initiator timestamps the message ( resp_rx_ts ). The Initiator decides a timestamp at which to send the Final message and starts a delay send operation. This allows to insert the timestamp at which the message will be sent ( final_tx_ts ) inside the message itself. The Final message is the only one containing a useful payload comprised of all timestamps the Initiator knows: poll_tx_ts resp_rx_ts final_tx_ts Upon reception of the Final message, the responder then has all six timestamps (RX and TX for three messages) in hand allowing it to calculate the average time of flight (ToF) of messages using the following figure and equations. Asymmetric Double-Sided Two-Way Ranging \\[ ToF = \\frac{T_{round1} \\cdot T_{round2} - T_{reply1} \\cdot T_{reply2}}{T_{round1} + T_{round2} + T_{reply1} + T_{reply2}} \\] Where $$ T_{round1} = resp\\_rx\\_ts - poll\\_tx\\_ts $$ \\[ T_{round2} = final\\_rx\\_ts - resp\\_tx\\_ts \\] \\[ T_{reply1} = resp\\_tx\\_ts - poll\\_rx\\_ts \\] \\[ T_{reply2} = final\\_tx\\_ts - resp\\_rx\\_ts \\] After performing the calculation, the Responder then knows the distance seperating it from the Initiator. (The inverse is not true. The Initiator does not have all timestamps required to calculate the distance).","title":"One-to-One"},{"location":"sections/reference/Interloc/how_it_works/distance/#one-to-many","text":"The drawback of the one-to-one algorithm is that, in a multi-agent scenario, three messages must be sent for each agent to know their distance to a single other robot. The number of messages for every agent to know its distance from every other agent grows factorially thus decreasing the refresh rate of the whole system. Instead of having every agent perform a 1:1 TWR with every other agent, the scheme presented previously is extended to allow multiple Responders. Instead of having one Initiator and one Responder, we have one Initiator and \\(N-1\\) Responders (every agent except for the Initiator). The message exchange is then very similar to the 1:1 scenario: The initiator sends the Init message which is received by all Responders simultaneously. Each Responder, in turns, sends the Response message. The Initiator receives all the messages and timestamps them all. The Initiator sends the final message now containing \\(N\\) response_rx_ts, one for each Responder. Each Responder then has the six timestamps needed to compute their distance from the Initiator. After \\(2 + N\\) messages, all the agents, other than the Initiator, have updated their distance from the Initiator. Each agent then takes turns becoming the Initiator every time allowing all other agents to update their position from the Initiator. The sequence is summarized in the following figure. Multi-agent Two Way Ranging implementation More details on this time-slotting mechanism can be found in the synchronisation page .","title":"One-to-Many"},{"location":"sections/reference/Interloc/how_it_works/distance/#further-reading","text":"The following application notes produced by Decawave can help understanding the algorithm used in the SwarmUS platform. They also contain some knowledge about different algorithms that could be implemented as well as corrections for non line-of-sight operation and calibrations in order to achieve maximum accuracy. Application Note APS006 - Part 1 Channel Effects on Range Accuracy Application Note APS006 - Part 2 NLOS Operation and Optimizations Application Note APS006 - Part 3 DW1000 Diagnostics for NLOS Channels Application Note APS011 - Sources of Error in Two Way Ranging Application Note APS013 - The Implementation of Two-Way Ranging with he DW1000 Application Note APS014 - Antennna Delay Calibration","title":"Further Reading"},{"location":"sections/reference/Interloc/how_it_works/intro/","text":"Interlocalisation - Introduction Interlocalisation is the feature allowing a HiveBoard-BeeBoard assembly to calculate its distance and angle to other HiveBoards. The distance is defined as the norm of the straight 3D line connecting two HiveBoards (if there is an elevation difference between both boards, this will show up in the distance measurement) while the angle (sometimes called azimuth) is the relative bearing of another HiveBoard with regards to the first. No elevation measurement is done, the system can therefore only work properly on a 2D plane. The following figure shows those two concepts with the distance marked \\(r\\) and the angle \\(\\theta\\) . Interlocalisation Concepts Info The 0\u00b0 location of a BeeBoard assembly is chosen during calibration . This way, it is always possible to align the 0\u00b0 of the interlocalisation engine with the front of the robot on which it is mounted. All measurements done by the interlocalisation engine are made available through Buzz's neighbor structure or via the HiveMind API . The following page gives a brief overview of how the system is organized from a hardware and software point of view. Other pages explain how distances are calculated , how angles are calculated and how all messages are synchronized between all HiveBoards . Hardware The interlocalisation feature is built around Decawave's DW1000 UWB chip . Each BeeBoard contains a single DW1000. A single BeeBoard is needed to calculate distances between two systems. On the other hand, in order to calculate angles, three BeeBoards must be plugged into a HiveBoard. One BeeBoard should be plugged into each of the HiveBoard's channels (A, B and C). Whether the BeeBoard is plugged into port 0 or 1 has no impact. HiveBoard Ports Note The BeeBoard plugged into channel B will act as the master in all exchanges. This means that distances and angles will be calculated relative to that specific BeeBoard. Because the boards are so close to each other, this has practically no impact. The BeeBoards must then be placed in a specific pattern using the holder found in the HiveBoard-BeeBoard-Mechanical GitHub repository and the whole system must be calibrated . BeeBoard Holder Important Calibrations are very sensitive to all elements involved in the assembly. Therefore, a new calibration must be done for any change in components (HiveBoard, BeeBoard, USB-C cable, port in which the BeeBoard is plugged, etc.) Software Architecture In the HiveMind firmware , interlocalisation is split between multiple threads and libraries. The measurements themselves are made in the BSP library. The BSP library is different for each compilation target. For a microcontroller build, the library is responsible for sending/receiving messages and calculating a distance and an angle. While for a ROS build, the library gets interlocalisation information from Gazebo and doesn't have any communication to handle. Measurements made in this low-level library are then pushed to the InterlocUpdateInputQueue . This queue feeds the Interloc library which is a high-level library responsible for filtering and storing interlocalisation data. Each time an update is pushed to the queue, a thread picks it up, filters it and updates the specific neighbor's position in the PositionsTable . A message is also sent to Buzz via the InterlocUpdateOutputQueue to notify it that an updated position is available for a given neighbor. Filtering of values is done using a very simple exponential moving average filter . $$ FilteredValue_t = \\alpha \\cdot UnfilteredValue_t + (1-\\alpha) \\cdot FilteredValue_{t-1} $$ Note For better results, this filter should be changed for something like a Kalman filter or a particle filter. Interlocalisation Software Architecture Usage As shown in the previous figure, interlocalisation data can be accessed via Buzz's neighbor structure or the MessageHandler (HiveMind API) . The message handler allows accessing more than the current calculated positions. It is possible to get the raw data used to calculate angles or get periodic dumps of all calculated positions. These features are mainly used for calibration and characterization purposes and examples on their usage can be found in the TestBench-Python repository .","title":"Introduction"},{"location":"sections/reference/Interloc/how_it_works/intro/#interlocalisation-introduction","text":"Interlocalisation is the feature allowing a HiveBoard-BeeBoard assembly to calculate its distance and angle to other HiveBoards. The distance is defined as the norm of the straight 3D line connecting two HiveBoards (if there is an elevation difference between both boards, this will show up in the distance measurement) while the angle (sometimes called azimuth) is the relative bearing of another HiveBoard with regards to the first. No elevation measurement is done, the system can therefore only work properly on a 2D plane. The following figure shows those two concepts with the distance marked \\(r\\) and the angle \\(\\theta\\) . Interlocalisation Concepts Info The 0\u00b0 location of a BeeBoard assembly is chosen during calibration . This way, it is always possible to align the 0\u00b0 of the interlocalisation engine with the front of the robot on which it is mounted. All measurements done by the interlocalisation engine are made available through Buzz's neighbor structure or via the HiveMind API . The following page gives a brief overview of how the system is organized from a hardware and software point of view. Other pages explain how distances are calculated , how angles are calculated and how all messages are synchronized between all HiveBoards .","title":"Interlocalisation - Introduction"},{"location":"sections/reference/Interloc/how_it_works/intro/#hardware","text":"The interlocalisation feature is built around Decawave's DW1000 UWB chip . Each BeeBoard contains a single DW1000. A single BeeBoard is needed to calculate distances between two systems. On the other hand, in order to calculate angles, three BeeBoards must be plugged into a HiveBoard. One BeeBoard should be plugged into each of the HiveBoard's channels (A, B and C). Whether the BeeBoard is plugged into port 0 or 1 has no impact. HiveBoard Ports Note The BeeBoard plugged into channel B will act as the master in all exchanges. This means that distances and angles will be calculated relative to that specific BeeBoard. Because the boards are so close to each other, this has practically no impact. The BeeBoards must then be placed in a specific pattern using the holder found in the HiveBoard-BeeBoard-Mechanical GitHub repository and the whole system must be calibrated . BeeBoard Holder Important Calibrations are very sensitive to all elements involved in the assembly. Therefore, a new calibration must be done for any change in components (HiveBoard, BeeBoard, USB-C cable, port in which the BeeBoard is plugged, etc.)","title":"Hardware"},{"location":"sections/reference/Interloc/how_it_works/intro/#software-architecture","text":"In the HiveMind firmware , interlocalisation is split between multiple threads and libraries. The measurements themselves are made in the BSP library. The BSP library is different for each compilation target. For a microcontroller build, the library is responsible for sending/receiving messages and calculating a distance and an angle. While for a ROS build, the library gets interlocalisation information from Gazebo and doesn't have any communication to handle. Measurements made in this low-level library are then pushed to the InterlocUpdateInputQueue . This queue feeds the Interloc library which is a high-level library responsible for filtering and storing interlocalisation data. Each time an update is pushed to the queue, a thread picks it up, filters it and updates the specific neighbor's position in the PositionsTable . A message is also sent to Buzz via the InterlocUpdateOutputQueue to notify it that an updated position is available for a given neighbor. Filtering of values is done using a very simple exponential moving average filter . $$ FilteredValue_t = \\alpha \\cdot UnfilteredValue_t + (1-\\alpha) \\cdot FilteredValue_{t-1} $$ Note For better results, this filter should be changed for something like a Kalman filter or a particle filter. Interlocalisation Software Architecture","title":"Software Architecture"},{"location":"sections/reference/Interloc/how_it_works/intro/#usage","text":"As shown in the previous figure, interlocalisation data can be accessed via Buzz's neighbor structure or the MessageHandler (HiveMind API) . The message handler allows accessing more than the current calculated positions. It is possible to get the raw data used to calculate angles or get periodic dumps of all calculated positions. These features are mainly used for calibration and characterization purposes and examples on their usage can be found in the TestBench-Python repository .","title":"Usage"},{"location":"sections/reference/Interloc/how_it_works/sync/","text":"Synchronization Synchronization of all agents between each other is used in order to have each agent send the correct message over UWB at the correct time. The Distance Measurement and Angle Measurement sections should be read before continuing in order to understand all the messages and their sequencing required to calculate distances and angles. Time-Slotting Overview As introduced in Distance Measurement , each agent must, in turns, become the initiator in a two-way ranging (TWR) sequence for all other agents to update their knowledge of the initiator's position. In order to accumulate enough messages to calculate an angle as described in Angle Measurement , an Angle section is added to each frame in which the initiator sends messages at a constant rate until enough messages are sent for the responders to be able to calculate an angle. The following figure is not to scale in regards to timings. See Timings for more information. Time Slotting Overview Once all agents have become an intiator, a dead time (SYNC) is used to elect the new SuperFrame Leader (the agent who will be the initiator in the first timeslot) timeslots are then alloted based on agent IDs (modulo the max number of agents in the swarm). Example Given a swarm of 5 agents with a SuperFrame Leader 3, slots (TWR Frames) would be alloted the following way: TWR Frame 1 : Agent 3 TWR Frame 2 : Agent 4 TWR Frame 3 : Agent 5 TWR Frame 4 : Agent 1 TWR Frame 5 : Agent 2 Note Timeslots are alloted based on the maximum number of agents in the swarm and the indivual agents IDs (configurable through the HiveMind build system, see README ). If there are less agents present than the maximum allowed value, some slots will remain empty. The same way, if an agent has an ID exceeding the maximum number of agents, it will not be able to interact properly with the other agents in the timeslots and will probably even break the slots for everyone. TLDR: Make sure the max number of agents in the swarm is greater or equal to the agent with the highest ID. Definitions The following section contains most definitions used within the code and documention relating to the timeslotting mechanism and the state machine implementing it. SuperFrame : Highest level of the timeslots, allows every agent to have its own TWR Frame TWR Frame : Slot in which an agent is the initiator in a TWR sequence SuperFrame Leader : ID of the agent selected to use TWR Frame 1 during the SYNC state Frame Leader : ID of the agent that is the initiator (sends the poll, final and angle messages) in the current TWR Frame State Machine Implementation The previous time-slotting mechanism is implemented in the microcontroller using a finite state machine (FSM). The FSM takes care of setting the DW1000 in the correct operating mode (RX, TX, etc.) at the appropriate time. Time Slotting FSM In normal operating mode, the black arrows show the possible state transitions. Some alternate modes (shown here with colors) can be enabled with the Calibration Python Tool to extract only some information in a timely manner. Every state is responsible for sending or receiving a specific UWB message. All operations are done at a specific time using the timings as coded in the InterlocTimeManager . Tip To facilitate debugging of the state transitions, an m_stateTracer circular queue was added in the InterlocStateHandler as a way to record state transitions and view the events leading up to the current state. From a debugger, simply watch InterlocBSPContainer::getStateHandler() to access the queue. Idle The Idle state is the entry point of the FSM. On first entry, or when a SuperFrame has finished (when the next Frame Leader would be the SuperFrame Leader ), the FSM goes to the Sync state. Otherwise, the FSM will go to Send Poll if it is the next Frame Leader or Wait Poll if it is not. This starts the TWR exchange . Sync The Sync state is used to elect a new SuperFrame Leader and at the same time, allow new agents (or any agents that are desynchronized) to resynchronize back with the others. In this state, all agents start listening for a message with a random timeout (longer than the time of a TWR Frame ). When a timeout is reached without having received a message, a Poll message is immediatly sent ( Send Poll ). That message is received by all other agents that still haven't timed out therefore making the first to timeout the SuperFrame Leader . Because this state is reached at the end of each SuperFrame and the timeout is random, the SuperFrame Leader is also chosen at random and changes for every SuperFrame . Send Poll The Send Poll state does exactly what it name says. It sends a Poll message (the first in a TWR exchange). The message contains the ID of the SuperFrame Leader so any newcommer to the swarm can know exactly where in the timeslots the swarm is curently located. Once sent, the FSM moves on to the Wait Response state. Wait Response The Wait Response state is used to receive all Response messages from the TWR exchange. In this state, the DW1000 is placed in RX mode (at the appropriate time) for the exact duration of a Response message. The message will then be received or the DW1000 will timeout. In any case, the FSM loops back to this state for the same number of iterations as the maximum number of agents in the swarm. Once all messages have been received (or timed out), the FSM goes to the Send Final state. Send Final In the Send Final state, the Final message of the TWR exchange is sent. The message contains the poll_tx_ts , final_tx_ts as well as the response_rx_rs for every response that was received in the Wait Response state. Once sent, the FSM goes to the Send Angle state. Send Angle The Send Angle state is responsible for sending multiple messages at a given interval. Each message will be received by the other agents that are in the Receive Angle state and used to calculate an angle . All messages contain a unique ID used to distiguish one message from the other on the receiver side. This state leads back to the Idle state as it is the last in the Frame Leader path of the FSM. This state can also be entered permenantly to calibrate a HiveBoard . Wait Poll In Wait Poll the DW1000 is enabled in RX mode to listen for a Poll message. If one is received, the FSM goes to the Send Response state. Otherwise, it goes back to Idle as no distance could be calculated without first receiving a Poll message. Send Response Send Response is responsible for sending the Response message of the TWR exchange. The message is sent at an exact time offset from the reception of the Poll message based on the agent's ID. This way, each agent responds in its timeslot without interfering with the responses from the other agents. From there, the FSM moves on to the Wait Final state. Wait Final The Wait Final state listens for a Final message containing all the information needed to calculate a distance. Whether it is received or not, the FSM goes to the Receive Angle state. Receive Angle In this state, each of the three DW1000s are placed in RX mode with a timeout equal to a little less than the remaining time before the next Poll message is to be sent. Every time a message is received on the three DW1000s, the ID of the messages are compared to be sure the same message was received on each antenna. Phase and time information for the messages are extracted for angle calculation . After each message, the receivers are reactivated with a timeout. This allows them to receive the maximum number of messages without staying stuck in this state forever; the FSM exits the state with enough time left to calculate a distance and angle ( Update Distance + Angle ) and go back to Idle before the start of the next TWR Frame . Update Distance + Angle This state is responsible for taking all the information collected through the TWR exchange and Receive Angle state and produce a new value of distance and angle for the agent that was Frame Leader . In the case some information is missing (e.g. we have not received the Final message, or if less than three BeeBoards are plugged, we don't have the angle information), only the measurements for which we have all the information are calulated. The produced values are fed back up to the higher layers of the HiveMind (see Introduction for more information) to be used in Buzz. From here, the FSM goes back to Idle and the cycle starts again. Timings As the system is time slotted, a time manager ( src/bsp/src/stm32/src/interloc/include/interloc/InterlocTimeManager.h ) has been established to ensure a coherence between all actions, synchronisation and state transition. This time manager computes all the timings for the start and stop times of all UWB operations. There are two tools to better visualise and understand the different timing restrictions and the definitions of all timing elements. An Excel file that emulates the calculations made on the HiveMind, allows the user to see the effects of all timing factors on the refresh rate of the relative position and angle from all agents in the swarm. Refer to this document if factors like the SPI speed, the number of frame angles per TWR frame or the number of robots changes. As the total time of a TWR Frame will be affected, the state machine speed will also change. From a visual aspect, the following figure presents all the major timing definitions used in the time slotting system (click to enlarge). Please refer to the source code for a complete comprehension of these and to see how they are used. The guards have be established from development experiments and from timing many operations on the actual MCU used. Other variables, such as the read and write SPI and the preamble air time are based on firmware configurations. The MCU and DW1000 configuration's can change these, make sure you know what you are doing before modifying any parameters . If for exemple the number of computations is changed in one of the states, it might be necessary to time the whole state's processing to ensure that the guards around these operations are still sufficient. Refer to this figure if new messages or states are added. All timings definitions are made as a delay after the Start of Frame (SoF). This SoF is reset every time a Poll message is received, ensuring a complete synchronisation of the FSM even in the case of clock drift or robot crash/reboot/deconnection.","title":"Synchronization"},{"location":"sections/reference/Interloc/how_it_works/sync/#synchronization","text":"Synchronization of all agents between each other is used in order to have each agent send the correct message over UWB at the correct time. The Distance Measurement and Angle Measurement sections should be read before continuing in order to understand all the messages and their sequencing required to calculate distances and angles.","title":"Synchronization"},{"location":"sections/reference/Interloc/how_it_works/sync/#time-slotting-overview","text":"As introduced in Distance Measurement , each agent must, in turns, become the initiator in a two-way ranging (TWR) sequence for all other agents to update their knowledge of the initiator's position. In order to accumulate enough messages to calculate an angle as described in Angle Measurement , an Angle section is added to each frame in which the initiator sends messages at a constant rate until enough messages are sent for the responders to be able to calculate an angle. The following figure is not to scale in regards to timings. See Timings for more information. Time Slotting Overview Once all agents have become an intiator, a dead time (SYNC) is used to elect the new SuperFrame Leader (the agent who will be the initiator in the first timeslot) timeslots are then alloted based on agent IDs (modulo the max number of agents in the swarm). Example Given a swarm of 5 agents with a SuperFrame Leader 3, slots (TWR Frames) would be alloted the following way: TWR Frame 1 : Agent 3 TWR Frame 2 : Agent 4 TWR Frame 3 : Agent 5 TWR Frame 4 : Agent 1 TWR Frame 5 : Agent 2 Note Timeslots are alloted based on the maximum number of agents in the swarm and the indivual agents IDs (configurable through the HiveMind build system, see README ). If there are less agents present than the maximum allowed value, some slots will remain empty. The same way, if an agent has an ID exceeding the maximum number of agents, it will not be able to interact properly with the other agents in the timeslots and will probably even break the slots for everyone. TLDR: Make sure the max number of agents in the swarm is greater or equal to the agent with the highest ID.","title":"Time-Slotting Overview"},{"location":"sections/reference/Interloc/how_it_works/sync/#definitions","text":"The following section contains most definitions used within the code and documention relating to the timeslotting mechanism and the state machine implementing it. SuperFrame : Highest level of the timeslots, allows every agent to have its own TWR Frame TWR Frame : Slot in which an agent is the initiator in a TWR sequence SuperFrame Leader : ID of the agent selected to use TWR Frame 1 during the SYNC state Frame Leader : ID of the agent that is the initiator (sends the poll, final and angle messages) in the current TWR Frame","title":"Definitions"},{"location":"sections/reference/Interloc/how_it_works/sync/#state-machine-implementation","text":"The previous time-slotting mechanism is implemented in the microcontroller using a finite state machine (FSM). The FSM takes care of setting the DW1000 in the correct operating mode (RX, TX, etc.) at the appropriate time. Time Slotting FSM In normal operating mode, the black arrows show the possible state transitions. Some alternate modes (shown here with colors) can be enabled with the Calibration Python Tool to extract only some information in a timely manner. Every state is responsible for sending or receiving a specific UWB message. All operations are done at a specific time using the timings as coded in the InterlocTimeManager . Tip To facilitate debugging of the state transitions, an m_stateTracer circular queue was added in the InterlocStateHandler as a way to record state transitions and view the events leading up to the current state. From a debugger, simply watch InterlocBSPContainer::getStateHandler() to access the queue.","title":"State Machine Implementation"},{"location":"sections/reference/Interloc/how_it_works/sync/#idle","text":"The Idle state is the entry point of the FSM. On first entry, or when a SuperFrame has finished (when the next Frame Leader would be the SuperFrame Leader ), the FSM goes to the Sync state. Otherwise, the FSM will go to Send Poll if it is the next Frame Leader or Wait Poll if it is not. This starts the TWR exchange .","title":"Idle"},{"location":"sections/reference/Interloc/how_it_works/sync/#sync","text":"The Sync state is used to elect a new SuperFrame Leader and at the same time, allow new agents (or any agents that are desynchronized) to resynchronize back with the others. In this state, all agents start listening for a message with a random timeout (longer than the time of a TWR Frame ). When a timeout is reached without having received a message, a Poll message is immediatly sent ( Send Poll ). That message is received by all other agents that still haven't timed out therefore making the first to timeout the SuperFrame Leader . Because this state is reached at the end of each SuperFrame and the timeout is random, the SuperFrame Leader is also chosen at random and changes for every SuperFrame .","title":"Sync"},{"location":"sections/reference/Interloc/how_it_works/sync/#send-poll","text":"The Send Poll state does exactly what it name says. It sends a Poll message (the first in a TWR exchange). The message contains the ID of the SuperFrame Leader so any newcommer to the swarm can know exactly where in the timeslots the swarm is curently located. Once sent, the FSM moves on to the Wait Response state.","title":"Send Poll"},{"location":"sections/reference/Interloc/how_it_works/sync/#wait-response","text":"The Wait Response state is used to receive all Response messages from the TWR exchange. In this state, the DW1000 is placed in RX mode (at the appropriate time) for the exact duration of a Response message. The message will then be received or the DW1000 will timeout. In any case, the FSM loops back to this state for the same number of iterations as the maximum number of agents in the swarm. Once all messages have been received (or timed out), the FSM goes to the Send Final state.","title":"Wait Response"},{"location":"sections/reference/Interloc/how_it_works/sync/#send-final","text":"In the Send Final state, the Final message of the TWR exchange is sent. The message contains the poll_tx_ts , final_tx_ts as well as the response_rx_rs for every response that was received in the Wait Response state. Once sent, the FSM goes to the Send Angle state.","title":"Send Final"},{"location":"sections/reference/Interloc/how_it_works/sync/#send-angle","text":"The Send Angle state is responsible for sending multiple messages at a given interval. Each message will be received by the other agents that are in the Receive Angle state and used to calculate an angle . All messages contain a unique ID used to distiguish one message from the other on the receiver side. This state leads back to the Idle state as it is the last in the Frame Leader path of the FSM. This state can also be entered permenantly to calibrate a HiveBoard .","title":"Send Angle"},{"location":"sections/reference/Interloc/how_it_works/sync/#wait-poll","text":"In Wait Poll the DW1000 is enabled in RX mode to listen for a Poll message. If one is received, the FSM goes to the Send Response state. Otherwise, it goes back to Idle as no distance could be calculated without first receiving a Poll message.","title":"Wait Poll"},{"location":"sections/reference/Interloc/how_it_works/sync/#send-response","text":"Send Response is responsible for sending the Response message of the TWR exchange. The message is sent at an exact time offset from the reception of the Poll message based on the agent's ID. This way, each agent responds in its timeslot without interfering with the responses from the other agents. From there, the FSM moves on to the Wait Final state.","title":"Send Response"},{"location":"sections/reference/Interloc/how_it_works/sync/#wait-final","text":"The Wait Final state listens for a Final message containing all the information needed to calculate a distance. Whether it is received or not, the FSM goes to the Receive Angle state.","title":"Wait Final"},{"location":"sections/reference/Interloc/how_it_works/sync/#receive-angle","text":"In this state, each of the three DW1000s are placed in RX mode with a timeout equal to a little less than the remaining time before the next Poll message is to be sent. Every time a message is received on the three DW1000s, the ID of the messages are compared to be sure the same message was received on each antenna. Phase and time information for the messages are extracted for angle calculation . After each message, the receivers are reactivated with a timeout. This allows them to receive the maximum number of messages without staying stuck in this state forever; the FSM exits the state with enough time left to calculate a distance and angle ( Update Distance + Angle ) and go back to Idle before the start of the next TWR Frame .","title":"Receive Angle"},{"location":"sections/reference/Interloc/how_it_works/sync/#update-distance-angle","text":"This state is responsible for taking all the information collected through the TWR exchange and Receive Angle state and produce a new value of distance and angle for the agent that was Frame Leader . In the case some information is missing (e.g. we have not received the Final message, or if less than three BeeBoards are plugged, we don't have the angle information), only the measurements for which we have all the information are calulated. The produced values are fed back up to the higher layers of the HiveMind (see Introduction for more information) to be used in Buzz. From here, the FSM goes back to Idle and the cycle starts again.","title":"Update Distance + Angle"},{"location":"sections/reference/Interloc/how_it_works/sync/#timings","text":"As the system is time slotted, a time manager ( src/bsp/src/stm32/src/interloc/include/interloc/InterlocTimeManager.h ) has been established to ensure a coherence between all actions, synchronisation and state transition. This time manager computes all the timings for the start and stop times of all UWB operations. There are two tools to better visualise and understand the different timing restrictions and the definitions of all timing elements. An Excel file that emulates the calculations made on the HiveMind, allows the user to see the effects of all timing factors on the refresh rate of the relative position and angle from all agents in the swarm. Refer to this document if factors like the SPI speed, the number of frame angles per TWR frame or the number of robots changes. As the total time of a TWR Frame will be affected, the state machine speed will also change. From a visual aspect, the following figure presents all the major timing definitions used in the time slotting system (click to enlarge). Please refer to the source code for a complete comprehension of these and to see how they are used. The guards have be established from development experiments and from timing many operations on the actual MCU used. Other variables, such as the read and write SPI and the preamble air time are based on firmware configurations. The MCU and DW1000 configuration's can change these, make sure you know what you are doing before modifying any parameters . If for exemple the number of computations is changed in one of the states, it might be necessary to time the whole state's processing to ensure that the guards around these operations are still sufficient. Refer to this figure if new messages or states are added. All timings definitions are made as a delay after the Start of Frame (SoF). This SoF is reset every time a Poll message is received, ensuring a complete synchronisation of the FSM even in the case of clock drift or robot crash/reboot/deconnection.","title":"Timings"},{"location":"sections/reference/Networking/configure-wifi/","text":"The easiest way to configure the Wi-Fi network on HiveBoards is by using the HiveAR Android application. Each HiveBoard will need to be configured individually, so the following procedure should be repeated for every board that you wish to connect to a same Wi-Fi network. Important Before you start, make sure you have the most recent version of the HiveAR app that can be found on the project GitHub page. The installation files are generated by the continuous integration pipeline as artifacts. You can download an APK file by clicking on one of the workflow runs and then selecting the apk file. Follow these instructions to connect an Android device running HiveAR to a HiveBoard. Then, follow the steps in the next section to set up the Wi-Fi network. Set up the Wi-Fi Network Important Before you set up the Wi-Fi Make sure that all the HiveBoards have their Wi-Fi antennas plugged in. This might save a few headaches. Navigate to the Settings view by tapping the wrench icon at the lower right of the screen. This contains a tab which allows for the configuration of the Wi-Fi network: Enter the configuration for the Wi-Fi network. There are a few different topologies that you might want to consider. Before you set up the network, refer to the limitations . External Router You can set up a Wi-Fi network using an external wireless router. This way, you'll want to connect all of the HiveBoards to that router. Enter the SSID and password of you external Wi-Fi network and tap Configure HiveBoard . This will load the configuration to the ESP-32 Wi-Fi module. Make sure the network respects the limitations . When the HiveBoard has successfully connected to the network, the networking status LED will turn green. Refer to the HiveBoard UI page for a comprehensive list of the RGB LED states. Single HiveBoard as a Router You can choose to use one of the HiveBoards to act as the router for the Wi-Fi network. That way, there is no need to provide an external router, and the swarm is able to work on its own. On the HiveBoard that you want to use as the router, check the Is Router box. Set the SSID and the password for the network. Tap Configure HiveBoard to load the configuration. Make sure the network respects the limitations . Once the router configuration has been loaded, the RGB LED for the ESP-32 will turn teal. Refer to the HiveBoard UI page for a comprehensive list of the RGB LED states. On the other HiveBoards, simply connect to the Wi-Fi network you just created. Make sure to leave the Is Router box unchecked . Mesh Networking As of now, the mesh networking is not implemented. Limitations There are a few limitations to consider when setting up a new Wi-Fi network to use with your HiveBoards: The ESP-32 chips only support 2.4 GHz Wi-Fi networks. 5 GHz band is not supported. The maximum length of the SSID is 32 characters. The minimum length of the password is 8 characters. Only WPA2-PSK is supported.","title":"Configuring the Wi-Fi network"},{"location":"sections/reference/Networking/configure-wifi/#set-up-the-wi-fi-network","text":"Important Before you set up the Wi-Fi Make sure that all the HiveBoards have their Wi-Fi antennas plugged in. This might save a few headaches. Navigate to the Settings view by tapping the wrench icon at the lower right of the screen. This contains a tab which allows for the configuration of the Wi-Fi network: Enter the configuration for the Wi-Fi network. There are a few different topologies that you might want to consider. Before you set up the network, refer to the limitations .","title":"Set up the Wi-Fi Network "},{"location":"sections/reference/Networking/configure-wifi/#external-router","text":"You can set up a Wi-Fi network using an external wireless router. This way, you'll want to connect all of the HiveBoards to that router. Enter the SSID and password of you external Wi-Fi network and tap Configure HiveBoard . This will load the configuration to the ESP-32 Wi-Fi module. Make sure the network respects the limitations . When the HiveBoard has successfully connected to the network, the networking status LED will turn green. Refer to the HiveBoard UI page for a comprehensive list of the RGB LED states.","title":"External Router"},{"location":"sections/reference/Networking/configure-wifi/#single-hiveboard-as-a-router","text":"You can choose to use one of the HiveBoards to act as the router for the Wi-Fi network. That way, there is no need to provide an external router, and the swarm is able to work on its own. On the HiveBoard that you want to use as the router, check the Is Router box. Set the SSID and the password for the network. Tap Configure HiveBoard to load the configuration. Make sure the network respects the limitations . Once the router configuration has been loaded, the RGB LED for the ESP-32 will turn teal. Refer to the HiveBoard UI page for a comprehensive list of the RGB LED states. On the other HiveBoards, simply connect to the Wi-Fi network you just created. Make sure to leave the Is Router box unchecked .","title":"Single HiveBoard as a Router"},{"location":"sections/reference/Networking/configure-wifi/#mesh-networking","text":"As of now, the mesh networking is not implemented.","title":"Mesh Networking"},{"location":"sections/reference/Networking/configure-wifi/#limitations","text":"There are a few limitations to consider when setting up a new Wi-Fi network to use with your HiveBoards: The ESP-32 chips only support 2.4 GHz Wi-Fi networks. 5 GHz band is not supported. The maximum length of the SSID is 32 characters. The minimum length of the password is 8 characters. Only WPA2-PSK is supported.","title":"Limitations"},{"location":"sections/reference/Networking/hiveconnect/","text":"HiveConnect HiveConnect is the firmware that runs on the ESP-32 MCU. It provides the WiFi communication stack to the messaging service, and allows the configuration of various network topologies, including mesh. The codebase for HiveConnect is hosted on GitHub .","title":"HiveConnect"},{"location":"sections/reference/Networking/hiveconnect/#hiveconnect","text":"HiveConnect is the firmware that runs on the ESP-32 MCU. It provides the WiFi communication stack to the messaging service, and allows the configuration of various network topologies, including mesh. The codebase for HiveConnect is hosted on GitHub .","title":"HiveConnect"},{"location":"sections/user-guide/","text":"User Guides Home The user guides provide step-by-step instructions to help users implement a swarm solution using SwarmUS. Complete newcomers will want to start with the basic examples , which show how to use the core features of the SwarmUS platform. Tip Users looking for information on more precise topics will want to refer to the Reference section section.","title":"User Guides Home"},{"location":"sections/user-guide/#user-guides-home","text":"The user guides provide step-by-step instructions to help users implement a swarm solution using SwarmUS. Complete newcomers will want to start with the basic examples , which show how to use the core features of the SwarmUS platform. Tip Users looking for information on more precise topics will want to refer to the Reference section section.","title":"User Guides Home"},{"location":"sections/user-guide/basic-examples/basic-interloc/","text":"Using Interlocalisation Between Swarm Agents One of the key features of the SwarmUS platform is the ability for a given Hiveboard to determine the position of other Hiveboards with respect to its own position. This page shows how to use this interlocalisation feature. SwarmUS' interlocalisation feature provides the necessary data to the neighbor feature of the Buzz language . This means that the HiveMind firmware merely updates the position of the other agents and makes it available to Buzz. Note The interlocalisation module is a rather complex feature of the SwarmUS platform. For extensive documentation about the design and implementation of the feature, refer to the How it Works section . Attention Before you start using the interlocalisation feature, refer to the instructions on how to calibrate the BeeBoards with a HiveBoard. Since the interlocalisation feature relies on very sensitive hardware, it is crucial that the HiveBoard/BeeBoard assembly be adequately calibrated, otherwise the readings will be rubbish. Using the Visualisation Tool When the interlocalisation is adequately calibrated, you can test that the HiveBoard/Beeboard assemblies can acquire their respective positions using the graphical visualisation tool . Refer to the README file for instructions on how to use the tool. Accessing Neighbors' Position in a Buzz Script As said earlier, Buzz has a neighbor management feature, which allows to access the position of the other agents, among other things. Note Since neighbor management is a feature of Buzz, it will not be extensively documented here. Refer to the official documentation and the language reference . The SwarmUS platform feeds the interlocalisation data to Buzz, which itself makes it available to the user via the neighbors structure. The following snippet shows how the neighbors structure might be used. This Buzz script performs a follow the leader example in which the agents will move towards the agent #1. include \"utils/executor.bzz\" include \"vec2.bzz\" function tick ( context ){ var leader = 1 ; if ( leader != id and leader != nil ){ log ( \"Trying to get leader: \" , leader ) var neighbor = neighbors . get ( leader ); if ( istable ( neighbor )){ # Set a new goal based on the interlocalisation data found in # the neighbor object var goal = math . vec2 . newp ( neighbor . distance - 0.5 , neighbor . azimuth ); log ( \"Moving to leader: \" , leader , \" at x:\" , goal . x , \" y:\" , goal . y ); # Move the robot toward the goal. call_host_function ( id , \"moveBy\" , { .0 = goal . x , .1 = goal . y }); } else { log ( \"Neighbor not found!\" ); } } } function create_exec ( step_count ) { counter = 0 ; exec = executor . new ( step_count , tick , nil ); return exec ; } This script uses Buzz' math.vec2 library (documentation here ). This library helps to handle 2D vectors. Neighbor management is performed with the neighbors structure. Each member of this structure has the attributes distance and azimuth . This is how the interlocalisation data is accessed. Verification of the neighbor is done using the istable function, documented here . Hint The Buzz documentation has some other examples ( here and here ) of scripts that make use of the neighbors structure. The HiveMind repository also has a number of examples . Testing in Simulation Using Gazebo The SwarmUS project relied heavily on the Gazebo simulator for the development. This repository contains the swarmus_ros_simulation package, which has some ready-made launchfiles that integrate all the software stack of the SwarmUS platform. Launching simple_swarm.launch will start 4 robots, each running a HiveMind instance. To change the Buzz script that will be used by all the robots in the simulation, edit the HiveMind codebase found under contrib/ folder. For instance, if you want to run a follow the leader simulation, add the code shown in the previous section to contrib/src/bittybuzz/buzz-scripts... . Accessing Neighbors Outside of Buzz The interlocalisation data can also be accessed outside of Buzz. The HiveMind API exposes neighbor requests ( GetNeighborsListRequest , GetNeighborRequest ) that can be called by any host. The calls to the HiveMind API for updating neighbors have been convieniently wrapped in the HiveMindBridge library .","title":"Using Interlocalisation Between Swarm Agents"},{"location":"sections/user-guide/basic-examples/basic-interloc/#using-interlocalisation-between-swarm-agents","text":"One of the key features of the SwarmUS platform is the ability for a given Hiveboard to determine the position of other Hiveboards with respect to its own position. This page shows how to use this interlocalisation feature. SwarmUS' interlocalisation feature provides the necessary data to the neighbor feature of the Buzz language . This means that the HiveMind firmware merely updates the position of the other agents and makes it available to Buzz. Note The interlocalisation module is a rather complex feature of the SwarmUS platform. For extensive documentation about the design and implementation of the feature, refer to the How it Works section . Attention Before you start using the interlocalisation feature, refer to the instructions on how to calibrate the BeeBoards with a HiveBoard. Since the interlocalisation feature relies on very sensitive hardware, it is crucial that the HiveBoard/BeeBoard assembly be adequately calibrated, otherwise the readings will be rubbish.","title":"Using Interlocalisation Between Swarm Agents"},{"location":"sections/user-guide/basic-examples/basic-interloc/#using-the-visualisation-tool","text":"When the interlocalisation is adequately calibrated, you can test that the HiveBoard/Beeboard assemblies can acquire their respective positions using the graphical visualisation tool . Refer to the README file for instructions on how to use the tool.","title":"Using the Visualisation Tool"},{"location":"sections/user-guide/basic-examples/basic-interloc/#accessing-neighbors-position-in-a-buzz-script","text":"As said earlier, Buzz has a neighbor management feature, which allows to access the position of the other agents, among other things. Note Since neighbor management is a feature of Buzz, it will not be extensively documented here. Refer to the official documentation and the language reference . The SwarmUS platform feeds the interlocalisation data to Buzz, which itself makes it available to the user via the neighbors structure. The following snippet shows how the neighbors structure might be used. This Buzz script performs a follow the leader example in which the agents will move towards the agent #1. include \"utils/executor.bzz\" include \"vec2.bzz\" function tick ( context ){ var leader = 1 ; if ( leader != id and leader != nil ){ log ( \"Trying to get leader: \" , leader ) var neighbor = neighbors . get ( leader ); if ( istable ( neighbor )){ # Set a new goal based on the interlocalisation data found in # the neighbor object var goal = math . vec2 . newp ( neighbor . distance - 0.5 , neighbor . azimuth ); log ( \"Moving to leader: \" , leader , \" at x:\" , goal . x , \" y:\" , goal . y ); # Move the robot toward the goal. call_host_function ( id , \"moveBy\" , { .0 = goal . x , .1 = goal . y }); } else { log ( \"Neighbor not found!\" ); } } } function create_exec ( step_count ) { counter = 0 ; exec = executor . new ( step_count , tick , nil ); return exec ; } This script uses Buzz' math.vec2 library (documentation here ). This library helps to handle 2D vectors. Neighbor management is performed with the neighbors structure. Each member of this structure has the attributes distance and azimuth . This is how the interlocalisation data is accessed. Verification of the neighbor is done using the istable function, documented here . Hint The Buzz documentation has some other examples ( here and here ) of scripts that make use of the neighbors structure. The HiveMind repository also has a number of examples .","title":"Accessing Neighbors' Position in a Buzz Script"},{"location":"sections/user-guide/basic-examples/basic-interloc/#testing-in-simulation-using-gazebo","text":"The SwarmUS project relied heavily on the Gazebo simulator for the development. This repository contains the swarmus_ros_simulation package, which has some ready-made launchfiles that integrate all the software stack of the SwarmUS platform. Launching simple_swarm.launch will start 4 robots, each running a HiveMind instance. To change the Buzz script that will be used by all the robots in the simulation, edit the HiveMind codebase found under contrib/ folder. For instance, if you want to run a follow the leader simulation, add the code shown in the previous section to contrib/src/bittybuzz/buzz-scripts... .","title":"Testing in Simulation Using Gazebo"},{"location":"sections/user-guide/basic-examples/basic-interloc/#accessing-neighbors-outside-of-buzz","text":"The interlocalisation data can also be accessed outside of Buzz. The HiveMind API exposes neighbor requests ( GetNeighborsListRequest , GetNeighborRequest ) that can be called by any host. The calls to the HiveMind API for updating neighbors have been convieniently wrapped in the HiveMindBridge library .","title":"Accessing Neighbors Outside of Buzz"},{"location":"sections/user-guide/basic-examples/buzz-control-robot/","text":"Controlling a robot using Buzz and HiveMindBridge Now that the code that runs on your Hiveboard can flash an LED of its own or one from a remote board , let's establish a connection between a Hiveboard and a robot's embedded computer. The goal here is to use a Buzz script to tele-operate a robot. Note To follow this user guide, you will need: A computer running Linux A robot running ROS. You really just need a computer running ROS to go through this tutorial, but you might want to have a full robot to test the integration. One HiveBoard and its power supply (wall adapter) A micro-USB to USB type A cable An Ethernet cable Initial Setup Important Before we start, make sure that the HiveBoard has a HiveMind firmware flashed. Follow the instructions from this previous tutorial to flash a firmware on the device. The HiveBoard connects to the robot's embedded computer using an Ethernet cable. Communication between the two is established via TCP. Connect the HiveBoard as shown in the image below. The micro-USB cable should be plugged into your computer since we will be flashing some Buzz code on the device. The Ethernet must be plugged into the robot's embedded computer. Power on the HiveBoard by setting the switch to the CON position. Network configuration The HiveMind firmware expects the robot's computer to have a precise IP address. In the robot's embedded computer, set a static IP address on the Ethernet network adapter with the following parameters: IPv4 address : 192.168.1.101 Subnet mask: 255.255.255.0 Tip The network configuration expected by HiveMind can be changed by using CMake variables. See HiveMind readme for more on this. The robot's embedded computer is refered to as the HOST . Testing the connection The HiveBoard has a static IP address set to 192.168.1.10 . From the embedded computer (we will call this the host from now on), try to ping the HiveBoard to see if the Ethernet connection works. Attention If ping fails, double check the previous steps and make sure that the power switch is indeed to the CON position, and not to USB . Next, open the COM port to see the HiveBoard's logs (usually dev/ttyUSB2 ). You should see that the HiveBoard attempts to connect to a host: This is expected at this point since there is no HiveMindBridge running on the host computer yet. Creating a Bridge for the robot Now that there is an Ethernet link between the HiveBoard and the host, we need to write some software that will act as a bridge between HiveMind (the HiveBoard's firmware) and the rest of the robot's software stack. From now on, we will assume that the robot runs ROS1 and has a fully working navigation stack, so we will show the setup accordignly. Note This User Guide aims to show how to interface the SwarmUS platform with robots that use ROS. However the platform is ROS-agnostic and the HiveMindBridge library could be used in any C++ code. See this example for a basic \"hello world\" example. The SwarmUS project comprises a C++ library named HiveMindBridge that helps interfacing the HiveBoard with the outside world. Using HiveMindBridge, you can define and expose an API from the robot to the swarm. Let's create a minimal ROS node that uses HiveMindBridge to show some basic capabilities. The robot will expose two simple functions to the swarm. Both functions are callable by other swarm agents or by the robot's HiveBoard: moveBy(float x, float y) : this function will forward moving commands to the robot's navigtion stack. moveBy is the entrypoint to control the robot's position remotely. The arguments x and y are displacement values relative to the robot's own position. The function does not return any payload. getStatus() : this function will return some payload containing some information about the robot's state. This (minimal) configuration will yield a simple robot that can be remote-controlled and that can inform on its state. Prerequisites to using HiveMindBridge HiveMindBridge is a C++ library that must be installed on a system, and then included to a software project using CMake. Before implementing the ROS node that uses HiveMindBridge, follow these instructions to build and install HiveMindBridge on the host computer. Make sure to use the provided commands from the CMake example within your ROS package's CMakeLists.txt . You might want to check this example implementation of a Bridge with a TurtleBot 3. HiveMindBridge : the unique entrypoint to the library Note The full API documentation for HiveMindBridge is hosted here . HiveMindBridge is a simple library that supports registering asynchronous callbacks to serve as a bridge between the communication services encapsulated in the swarm services and the local ROS environment. The user will mainly use the HiveMindBridge class to register custom actions, send some data over the messaging service and control the execution flow. Instantiating a HiveMindBridge object is done using the class' only constructor : // HiveMindBridge.h HiveMindBridge ( int tcpPort , ILogger & logger ) HiveMindBridge uses a TCP socket server underneath and requires that the user provide a port for the connection. The second input argument is a logger that must be injected. The logger must implement the ILogger interface (a basic working implementation is provided here ). Full example The following listing shows the basic example, where the two aforementioned functions are registered ( moveBy(x, y) and getStatus() ). This example is used within a ROS application context. We left the ROS-specific calls in the example to ease understanding. Note however that HiveMindBridge is completely ROS-agnostic, and could be used in a plain C++ project. We will break everything down after this listing. #include \"hivemind-bridge/Callback.h\" #include \"hivemind-bridge/HiveMindBridge.h\" #include \"ros/ros.h\" #include \"swarmus_ros_navigation/MoveByMessage.h\" #include <cpp-common/ILogger.h> #include <cstdarg> #include <optional> #include <pheromones/FunctionCallArgumentDTO.h> int main ( int argc , char ** argv ) { ros :: init ( argc , argv , \"hive_mind_bridge\" ); ros :: NodeHandle nodeHandle ( \"~\" ); // ROS publisher: this will publish the moveBy command to the navigation stack std :: string moveByTopic = nodeHandle . param ( \"moveByTopic\" , std :: string ( \"/agent1/navigation/moveBy\" )); ros :: Publisher moveByPublisher = nodeHandle . advertise < swarmus_ros_navigation :: MoveByMessage > ( moveByTopic , 1000 ); int port = 7001 ; Logger logger ; // See above for more info on loggers. For this example, // let's just assume the class is accessible within the scope of this file. // Create a HiveMindBridge object HiveMindBridge bridge ( port , logger ); // Register the first custom action: moveBy(x, y). This function will simply forward the x and y values // to the navigation stack using a ROS publisher. CallbackFunction moveByCallback = [ & ]( CallbackArgs args ) -> std :: optional < CallbackReturn > { if ( argsLength != 2 ) { ROS_WARN ( \"Received incorrect number of arguments in moveBy\" ); return {}; } swarmus_ros_navigation :: MoveByMessage moveByMessage ; auto * x = std :: get_if < float > ( & args [ 0 ]. getArgument ()); // The arguments are contained // in `args`. The body of the function is where users should define the position of the arguments. auto * y = std :: get_if < float > ( & args [ 1 ]. getArgument ()); if ( x == nullptr || y == nullptr ) { ROS_WARN ( \"Received invalid argument type in moveBy\" ); return {}; } moveByMessage . distance_x = * x ; moveByMessage . distance_y = * y ; // Publish on moveby topic moveByPublisher . publish ( moveByMessage ); return {}; // This function does not return any payload, so we return an empty struct }; // Register the function's manifest, name and pointer in our `HiveMindBridge` object. CallbackArgsManifest moveByManifest ; moveByManifest . push_back ( UserCallbackArgumentDescription ( \"x\" , FunctionDescriptionArgumentTypeDTO :: Float )); moveByManifest . push_back ( UserCallbackArgumentDescription ( \"y\" , FunctionDescriptionArgumentTypeDTO :: Float )); bridge . registerCustomAction ( \"moveBy\" , moveByCallback , moveByManifest ); // Register the second custom action: getStatus() CallbackFunction getStatus = [ & ]( CallbackArgs args ) -> std :: optional < CallbackReturn > { int64_t isRobotOk = 1 ; // Let's assume there is some complex logic here // to check the status of the robot's components... // Build the return payload and return. CallbackArgs returnArgs ; returnArgs . push_back ( FunctionCallArgumentDTO ( isRobotOk )); CallbackReturn cbReturn ( \"getStatusReturn\" , returnArgs ); return cbReturn ; }; // Register the name and pointer for the getStatus() function. // Notice that no manifest is passed, since this function takes no input argument. bridge . registerCustomAction ( \"getStatus\" , getStatus ); // Register event hooks. HiveMindBridge provides a few event hooks that allow // the user to control the execution flow. bridge . onConnect ([]() { ROS_INFO ( \"Client connected.\" ); }); bridge . onDisconnect ([]() { ROS_INFO ( \"Client disconnected.\" ); }); // The main application loop ros :: Rate loopRate ( RATE_HZ ); while ( ros :: ok ()) { ros :: spinOnce (); bridge . spin (); loopRate . sleep (); } return 0 ; } Creating a HiveMindBridge object int port = 7001 ; Logger logger ; HiveMindBridge bridge ( port , logger ); To create a HiveMindBridge instance, the user must provide a logger that implements the ILogger interface (see here for a full example). The port input argument is needed in order to bind the TCP socket used by HiveMindBridge. Hint HiveMindBridge acts as a TCP server and will wait for clients to initiate a connection. Registering custom actions The example above shows the registration of two functions, moveBy(x, y) and getStatus() . Both have their own characteristics which help illustrate the capabilities of HiveMindBridge. Registering custom actions is always done by following three steps : Define the callback that describes the behaviour of the custom action (see Defining Callbacks ). Define the manifest that describes the input arguments of the callback (see Defining Manifests . This is optional, as some callbacks will not require any input arguments) Register the custom action in the HiveMindBridge object (see Registering Custom Actions ). Registering moveBy(float x, float y) The moveBy(float x, float y) function takes two arguments and returns no payload. This function simply forwards the two input arguments to the navigation stack by publishing on a ROS topic. CallbackFunction moveByCallback = [ & ]( CallbackArgs args ) -> std :: optional < CallbackReturn > { if ( argsLength != 2 ) { ROS_WARN ( \"Received incorrect number of arguments in moveBy\" ); return {}; } swarmus_ros_navigation :: MoveByMessage moveByMessage ; auto * x = std :: get_if < float > ( & args [ 0 ]. getArgument ()); auto * y = std :: get_if < float > ( & args [ 1 ]. getArgument ()); if ( x == nullptr || y == nullptr ) { ROS_WARN ( \"Received invalid argument type in moveBy\" ); return {}; } moveByMessage . distance_x = * x ; moveByMessage . distance_y = * y ; moveByPublisher . publish ( moveByMessage ); return {}; }; CallbackArgsManifest moveByManifest ; moveByManifest . push_back ( UserCallbackArgumentDescription ( \"x\" , FunctionDescriptionArgumentTypeDTO :: Float )); moveByManifest . push_back ( UserCallbackArgumentDescription ( \"y\" , FunctionDescriptionArgumentTypeDTO :: Float )); bridge . registerCustomAction ( \"moveBy\" , moveByCallback , moveByManifest ); Since the function returns no payload, the user must simply return an empty struct. Important Notice that the order of the arguments match between the manifest and the callback's body. This allows the other swarm element to send the arguments correctly. For more information on this, see Defining Manifests . Registering getStatus() The getStatus() function takes no input arguments, but will return some payload. The return payload is wrapped in a CallbackReturn type that takes the return values in a vector. This is because the return payload is wrapped in a function call request that will be placed on the remote caller. See Defining Callbacks for more details. CallbackFunction getStatus = [ & ]( CallbackArgs args ) -> std :: optional < CallbackReturn > { int64_t isRobotOk = 1 ; // Build the return payload and return. CallbackArgs returnArgs ; returnArgs . push_back ( FunctionCallArgumentDTO ( isRobotOk )); CallbackReturn cbReturn ( \"getStatusReturn\" , returnArgs ); return cbReturn ; }; bridge . registerCustomAction ( \"getStatus\" , getStatus ); Note This example does not have any real logic. In some cases, there could be a need to implement some complex logic, and even some blocking calls to check the state of some robot peripherals. Since all callbacks are run asynchronously, the user can use blocking calls in the body of the callback. See Defining Callbacks for more information on this. Registering event hooks HiveMindBridge provides some events that the user can attach hooks to, in order to control the execution flow. For example, the onConnect and onDisconnect event can fire user-defined callbacks when the TCP socket's state changes. This can prove useful to halt a robot in the event of a connection error. bridge . onConnect ([]() { ROS_INFO ( \"Client connected.\" ); }); bridge . onDisconnect ([]() { ROS_INFO ( \"Client disconnected.\" ); }); Spinning the Bridge HiveMindBridge has a main thread that must attach to the main application loop. The HiveMindBridge object must be spun for it to process the incoming data. // The main application loop ros :: Rate loopRate ( RATE_HZ ); while ( ros :: ok ()) { ros :: spinOnce (); bridge . spin (); // Spinning the bridge loopRate . sleep (); } Writing a Buzz Script to Control the Robot Now that we have written a bridge for the host-side, let's write a Buzz script that sends MoveBy commands over to the host. Open the HiveMind codebase and navigate to the folder src/bittybuzz/buzz_scripts , where the user-defined Buzz scripts are located. Hint The basics on how create and flash a Buzz script to a HiveBoard are explained in a previous User Guide . Create a new file called teleop.bzz containing the following commands. In main.bzz , make sure to include teleop.bzz at the top of the file. include \"utils/executor.bzz\" ctx = {}; function tick (){ log ( \"Calling host function...\" ); call_host_function ( id , \"moveBy\" , { .0 = 1.0 , .1 = 1.0 }); } function create_exec (){ exec = executor . new ( 10 , tick , ctx ); return exec ; } This script creates an executor (see this previous User Guide for more on executors ) which will run the tick function periodically. This function contains a call_host_function() command that will call a function that was exposed by the host's bridge. You must provide three arguments to this function: The id of the current HiveBoard. This is accessed via a global object id . The Agent ID is specific to each board and is destined to be shared between the HiveBoard and its host. The name of the function to be called on the host. The spelling of this string must be exactly the same as the function registered against the host's bridge . An array of parameters that are to be passed to the function. Refer to the API documentation for a complete description of all the available functions. You may now flash the HiveBoard with this code. Greeting the HiveBoard Now that we have a working bridge implementation, let's test that it can talk with HiveMind, the HiveBoard's firmware. First, make sure that everything is connected like in the image shown earlier . On you PC, open the COM port to view the logs from the HiveBoard (Usually dev/ttyUSB2 ). You should see some messages indicating that the HiveBoard Could not connect to server 192.168.1.101 : 7001 . Next, run the ROS node that we just created on the host computer. Watch the logs from the COM port. After a few seconds, you should see that the host greeted the HiveBoard: Greet succeeded in host_monitor The RGB LED at the bottom of the board should turn from purple to blue when the greet succeeds. This means that the HiveBoard and the host computer now form an agent of the swarm. Both share the same Swarm Agent ID , a unique identifier that each agent must hold for as long as it is a part of the swarm. The greeting procedure ensures that the host picks up the ID from the HiveBoard. Important The Swarm IDs are determined by the HiveBoards themselves. Each HiveBoard has a UUID saved in its non-volatile memory that is provided to the host upon greeting. The instructions on how to flash an ID to the HiveBoard are written in HiveMind's Readme . Testing the moveBy command Now that the HiveBoard and the bridge running on the host computer are both communicating together, we'll make sure that the moveBy function called from the Buzz script is indeed forwarded to the ROS environment. Open a terminal on the host computer and run rostopic echo /agent1/navigation/moveBy . You should see some messages: --- distance_x: 1.0 distance_y: 1.0","title":"Controlling a Robot Using Buzz and HiveMindBridge"},{"location":"sections/user-guide/basic-examples/buzz-control-robot/#controlling-a-robot-using-buzz-and-hivemindbridge","text":"Now that the code that runs on your Hiveboard can flash an LED of its own or one from a remote board , let's establish a connection between a Hiveboard and a robot's embedded computer. The goal here is to use a Buzz script to tele-operate a robot. Note To follow this user guide, you will need: A computer running Linux A robot running ROS. You really just need a computer running ROS to go through this tutorial, but you might want to have a full robot to test the integration. One HiveBoard and its power supply (wall adapter) A micro-USB to USB type A cable An Ethernet cable","title":"Controlling a robot using Buzz and HiveMindBridge"},{"location":"sections/user-guide/basic-examples/buzz-control-robot/#initial-setup","text":"Important Before we start, make sure that the HiveBoard has a HiveMind firmware flashed. Follow the instructions from this previous tutorial to flash a firmware on the device. The HiveBoard connects to the robot's embedded computer using an Ethernet cable. Communication between the two is established via TCP. Connect the HiveBoard as shown in the image below. The micro-USB cable should be plugged into your computer since we will be flashing some Buzz code on the device. The Ethernet must be plugged into the robot's embedded computer. Power on the HiveBoard by setting the switch to the CON position.","title":"Initial Setup"},{"location":"sections/user-guide/basic-examples/buzz-control-robot/#network-configuration","text":"The HiveMind firmware expects the robot's computer to have a precise IP address. In the robot's embedded computer, set a static IP address on the Ethernet network adapter with the following parameters: IPv4 address : 192.168.1.101 Subnet mask: 255.255.255.0 Tip The network configuration expected by HiveMind can be changed by using CMake variables. See HiveMind readme for more on this. The robot's embedded computer is refered to as the HOST .","title":"Network configuration"},{"location":"sections/user-guide/basic-examples/buzz-control-robot/#testing-the-connection","text":"The HiveBoard has a static IP address set to 192.168.1.10 . From the embedded computer (we will call this the host from now on), try to ping the HiveBoard to see if the Ethernet connection works. Attention If ping fails, double check the previous steps and make sure that the power switch is indeed to the CON position, and not to USB . Next, open the COM port to see the HiveBoard's logs (usually dev/ttyUSB2 ). You should see that the HiveBoard attempts to connect to a host: This is expected at this point since there is no HiveMindBridge running on the host computer yet.","title":"Testing the connection"},{"location":"sections/user-guide/basic-examples/buzz-control-robot/#creating-a-bridge-for-the-robot","text":"Now that there is an Ethernet link between the HiveBoard and the host, we need to write some software that will act as a bridge between HiveMind (the HiveBoard's firmware) and the rest of the robot's software stack. From now on, we will assume that the robot runs ROS1 and has a fully working navigation stack, so we will show the setup accordignly. Note This User Guide aims to show how to interface the SwarmUS platform with robots that use ROS. However the platform is ROS-agnostic and the HiveMindBridge library could be used in any C++ code. See this example for a basic \"hello world\" example. The SwarmUS project comprises a C++ library named HiveMindBridge that helps interfacing the HiveBoard with the outside world. Using HiveMindBridge, you can define and expose an API from the robot to the swarm. Let's create a minimal ROS node that uses HiveMindBridge to show some basic capabilities. The robot will expose two simple functions to the swarm. Both functions are callable by other swarm agents or by the robot's HiveBoard: moveBy(float x, float y) : this function will forward moving commands to the robot's navigtion stack. moveBy is the entrypoint to control the robot's position remotely. The arguments x and y are displacement values relative to the robot's own position. The function does not return any payload. getStatus() : this function will return some payload containing some information about the robot's state. This (minimal) configuration will yield a simple robot that can be remote-controlled and that can inform on its state.","title":"Creating a Bridge for the robot"},{"location":"sections/user-guide/basic-examples/buzz-control-robot/#prerequisites-to-using-hivemindbridge","text":"HiveMindBridge is a C++ library that must be installed on a system, and then included to a software project using CMake. Before implementing the ROS node that uses HiveMindBridge, follow these instructions to build and install HiveMindBridge on the host computer. Make sure to use the provided commands from the CMake example within your ROS package's CMakeLists.txt . You might want to check this example implementation of a Bridge with a TurtleBot 3.","title":"Prerequisites to using HiveMindBridge"},{"location":"sections/user-guide/basic-examples/buzz-control-robot/#hivemindbridge-the-unique-entrypoint-to-the-library","text":"Note The full API documentation for HiveMindBridge is hosted here . HiveMindBridge is a simple library that supports registering asynchronous callbacks to serve as a bridge between the communication services encapsulated in the swarm services and the local ROS environment. The user will mainly use the HiveMindBridge class to register custom actions, send some data over the messaging service and control the execution flow. Instantiating a HiveMindBridge object is done using the class' only constructor : // HiveMindBridge.h HiveMindBridge ( int tcpPort , ILogger & logger ) HiveMindBridge uses a TCP socket server underneath and requires that the user provide a port for the connection. The second input argument is a logger that must be injected. The logger must implement the ILogger interface (a basic working implementation is provided here ).","title":"HiveMindBridge: the unique entrypoint to the library"},{"location":"sections/user-guide/basic-examples/buzz-control-robot/#full-example","text":"The following listing shows the basic example, where the two aforementioned functions are registered ( moveBy(x, y) and getStatus() ). This example is used within a ROS application context. We left the ROS-specific calls in the example to ease understanding. Note however that HiveMindBridge is completely ROS-agnostic, and could be used in a plain C++ project. We will break everything down after this listing. #include \"hivemind-bridge/Callback.h\" #include \"hivemind-bridge/HiveMindBridge.h\" #include \"ros/ros.h\" #include \"swarmus_ros_navigation/MoveByMessage.h\" #include <cpp-common/ILogger.h> #include <cstdarg> #include <optional> #include <pheromones/FunctionCallArgumentDTO.h> int main ( int argc , char ** argv ) { ros :: init ( argc , argv , \"hive_mind_bridge\" ); ros :: NodeHandle nodeHandle ( \"~\" ); // ROS publisher: this will publish the moveBy command to the navigation stack std :: string moveByTopic = nodeHandle . param ( \"moveByTopic\" , std :: string ( \"/agent1/navigation/moveBy\" )); ros :: Publisher moveByPublisher = nodeHandle . advertise < swarmus_ros_navigation :: MoveByMessage > ( moveByTopic , 1000 ); int port = 7001 ; Logger logger ; // See above for more info on loggers. For this example, // let's just assume the class is accessible within the scope of this file. // Create a HiveMindBridge object HiveMindBridge bridge ( port , logger ); // Register the first custom action: moveBy(x, y). This function will simply forward the x and y values // to the navigation stack using a ROS publisher. CallbackFunction moveByCallback = [ & ]( CallbackArgs args ) -> std :: optional < CallbackReturn > { if ( argsLength != 2 ) { ROS_WARN ( \"Received incorrect number of arguments in moveBy\" ); return {}; } swarmus_ros_navigation :: MoveByMessage moveByMessage ; auto * x = std :: get_if < float > ( & args [ 0 ]. getArgument ()); // The arguments are contained // in `args`. The body of the function is where users should define the position of the arguments. auto * y = std :: get_if < float > ( & args [ 1 ]. getArgument ()); if ( x == nullptr || y == nullptr ) { ROS_WARN ( \"Received invalid argument type in moveBy\" ); return {}; } moveByMessage . distance_x = * x ; moveByMessage . distance_y = * y ; // Publish on moveby topic moveByPublisher . publish ( moveByMessage ); return {}; // This function does not return any payload, so we return an empty struct }; // Register the function's manifest, name and pointer in our `HiveMindBridge` object. CallbackArgsManifest moveByManifest ; moveByManifest . push_back ( UserCallbackArgumentDescription ( \"x\" , FunctionDescriptionArgumentTypeDTO :: Float )); moveByManifest . push_back ( UserCallbackArgumentDescription ( \"y\" , FunctionDescriptionArgumentTypeDTO :: Float )); bridge . registerCustomAction ( \"moveBy\" , moveByCallback , moveByManifest ); // Register the second custom action: getStatus() CallbackFunction getStatus = [ & ]( CallbackArgs args ) -> std :: optional < CallbackReturn > { int64_t isRobotOk = 1 ; // Let's assume there is some complex logic here // to check the status of the robot's components... // Build the return payload and return. CallbackArgs returnArgs ; returnArgs . push_back ( FunctionCallArgumentDTO ( isRobotOk )); CallbackReturn cbReturn ( \"getStatusReturn\" , returnArgs ); return cbReturn ; }; // Register the name and pointer for the getStatus() function. // Notice that no manifest is passed, since this function takes no input argument. bridge . registerCustomAction ( \"getStatus\" , getStatus ); // Register event hooks. HiveMindBridge provides a few event hooks that allow // the user to control the execution flow. bridge . onConnect ([]() { ROS_INFO ( \"Client connected.\" ); }); bridge . onDisconnect ([]() { ROS_INFO ( \"Client disconnected.\" ); }); // The main application loop ros :: Rate loopRate ( RATE_HZ ); while ( ros :: ok ()) { ros :: spinOnce (); bridge . spin (); loopRate . sleep (); } return 0 ; }","title":"Full example"},{"location":"sections/user-guide/basic-examples/buzz-control-robot/#creating-a-hivemindbridge-object","text":"int port = 7001 ; Logger logger ; HiveMindBridge bridge ( port , logger ); To create a HiveMindBridge instance, the user must provide a logger that implements the ILogger interface (see here for a full example). The port input argument is needed in order to bind the TCP socket used by HiveMindBridge. Hint HiveMindBridge acts as a TCP server and will wait for clients to initiate a connection.","title":"Creating a HiveMindBridge object"},{"location":"sections/user-guide/basic-examples/buzz-control-robot/#registering-custom-actions","text":"The example above shows the registration of two functions, moveBy(x, y) and getStatus() . Both have their own characteristics which help illustrate the capabilities of HiveMindBridge. Registering custom actions is always done by following three steps : Define the callback that describes the behaviour of the custom action (see Defining Callbacks ). Define the manifest that describes the input arguments of the callback (see Defining Manifests . This is optional, as some callbacks will not require any input arguments) Register the custom action in the HiveMindBridge object (see Registering Custom Actions ). Registering moveBy(float x, float y) The moveBy(float x, float y) function takes two arguments and returns no payload. This function simply forwards the two input arguments to the navigation stack by publishing on a ROS topic. CallbackFunction moveByCallback = [ & ]( CallbackArgs args ) -> std :: optional < CallbackReturn > { if ( argsLength != 2 ) { ROS_WARN ( \"Received incorrect number of arguments in moveBy\" ); return {}; } swarmus_ros_navigation :: MoveByMessage moveByMessage ; auto * x = std :: get_if < float > ( & args [ 0 ]. getArgument ()); auto * y = std :: get_if < float > ( & args [ 1 ]. getArgument ()); if ( x == nullptr || y == nullptr ) { ROS_WARN ( \"Received invalid argument type in moveBy\" ); return {}; } moveByMessage . distance_x = * x ; moveByMessage . distance_y = * y ; moveByPublisher . publish ( moveByMessage ); return {}; }; CallbackArgsManifest moveByManifest ; moveByManifest . push_back ( UserCallbackArgumentDescription ( \"x\" , FunctionDescriptionArgumentTypeDTO :: Float )); moveByManifest . push_back ( UserCallbackArgumentDescription ( \"y\" , FunctionDescriptionArgumentTypeDTO :: Float )); bridge . registerCustomAction ( \"moveBy\" , moveByCallback , moveByManifest ); Since the function returns no payload, the user must simply return an empty struct. Important Notice that the order of the arguments match between the manifest and the callback's body. This allows the other swarm element to send the arguments correctly. For more information on this, see Defining Manifests . Registering getStatus() The getStatus() function takes no input arguments, but will return some payload. The return payload is wrapped in a CallbackReturn type that takes the return values in a vector. This is because the return payload is wrapped in a function call request that will be placed on the remote caller. See Defining Callbacks for more details. CallbackFunction getStatus = [ & ]( CallbackArgs args ) -> std :: optional < CallbackReturn > { int64_t isRobotOk = 1 ; // Build the return payload and return. CallbackArgs returnArgs ; returnArgs . push_back ( FunctionCallArgumentDTO ( isRobotOk )); CallbackReturn cbReturn ( \"getStatusReturn\" , returnArgs ); return cbReturn ; }; bridge . registerCustomAction ( \"getStatus\" , getStatus ); Note This example does not have any real logic. In some cases, there could be a need to implement some complex logic, and even some blocking calls to check the state of some robot peripherals. Since all callbacks are run asynchronously, the user can use blocking calls in the body of the callback. See Defining Callbacks for more information on this.","title":"Registering custom actions"},{"location":"sections/user-guide/basic-examples/buzz-control-robot/#registering-event-hooks","text":"HiveMindBridge provides some events that the user can attach hooks to, in order to control the execution flow. For example, the onConnect and onDisconnect event can fire user-defined callbacks when the TCP socket's state changes. This can prove useful to halt a robot in the event of a connection error. bridge . onConnect ([]() { ROS_INFO ( \"Client connected.\" ); }); bridge . onDisconnect ([]() { ROS_INFO ( \"Client disconnected.\" ); });","title":"Registering event hooks"},{"location":"sections/user-guide/basic-examples/buzz-control-robot/#spinning-the-bridge","text":"HiveMindBridge has a main thread that must attach to the main application loop. The HiveMindBridge object must be spun for it to process the incoming data. // The main application loop ros :: Rate loopRate ( RATE_HZ ); while ( ros :: ok ()) { ros :: spinOnce (); bridge . spin (); // Spinning the bridge loopRate . sleep (); }","title":"Spinning the Bridge"},{"location":"sections/user-guide/basic-examples/buzz-control-robot/#writing-a-buzz-script-to-control-the-robot","text":"Now that we have written a bridge for the host-side, let's write a Buzz script that sends MoveBy commands over to the host. Open the HiveMind codebase and navigate to the folder src/bittybuzz/buzz_scripts , where the user-defined Buzz scripts are located. Hint The basics on how create and flash a Buzz script to a HiveBoard are explained in a previous User Guide . Create a new file called teleop.bzz containing the following commands. In main.bzz , make sure to include teleop.bzz at the top of the file. include \"utils/executor.bzz\" ctx = {}; function tick (){ log ( \"Calling host function...\" ); call_host_function ( id , \"moveBy\" , { .0 = 1.0 , .1 = 1.0 }); } function create_exec (){ exec = executor . new ( 10 , tick , ctx ); return exec ; } This script creates an executor (see this previous User Guide for more on executors ) which will run the tick function periodically. This function contains a call_host_function() command that will call a function that was exposed by the host's bridge. You must provide three arguments to this function: The id of the current HiveBoard. This is accessed via a global object id . The Agent ID is specific to each board and is destined to be shared between the HiveBoard and its host. The name of the function to be called on the host. The spelling of this string must be exactly the same as the function registered against the host's bridge . An array of parameters that are to be passed to the function. Refer to the API documentation for a complete description of all the available functions. You may now flash the HiveBoard with this code.","title":"Writing a Buzz Script to Control the Robot"},{"location":"sections/user-guide/basic-examples/buzz-control-robot/#greeting-the-hiveboard","text":"Now that we have a working bridge implementation, let's test that it can talk with HiveMind, the HiveBoard's firmware. First, make sure that everything is connected like in the image shown earlier . On you PC, open the COM port to view the logs from the HiveBoard (Usually dev/ttyUSB2 ). You should see some messages indicating that the HiveBoard Could not connect to server 192.168.1.101 : 7001 . Next, run the ROS node that we just created on the host computer. Watch the logs from the COM port. After a few seconds, you should see that the host greeted the HiveBoard: Greet succeeded in host_monitor The RGB LED at the bottom of the board should turn from purple to blue when the greet succeeds. This means that the HiveBoard and the host computer now form an agent of the swarm. Both share the same Swarm Agent ID , a unique identifier that each agent must hold for as long as it is a part of the swarm. The greeting procedure ensures that the host picks up the ID from the HiveBoard. Important The Swarm IDs are determined by the HiveBoards themselves. Each HiveBoard has a UUID saved in its non-volatile memory that is provided to the host upon greeting. The instructions on how to flash an ID to the HiveBoard are written in HiveMind's Readme .","title":"Greeting the HiveBoard"},{"location":"sections/user-guide/basic-examples/buzz-control-robot/#testing-the-moveby-command","text":"Now that the HiveBoard and the bridge running on the host computer are both communicating together, we'll make sure that the moveBy function called from the Buzz script is indeed forwarded to the ROS environment. Open a terminal on the host computer and run rostopic echo /agent1/navigation/moveBy . You should see some messages: --- distance_x: 1.0 distance_y: 1.0","title":"Testing the moveBy command"},{"location":"sections/user-guide/basic-examples/led-flash-buzz/","text":"Flahshing an LED using Buzz This page presents the steps to write a first basic Buzz script and load it on a HiveBoard. The script will make an LED flash on the board. Note To follow this user guide, you will need: A computer running Linux One HiveBoard and its power supply (wall adapter) A micro-USB to USB type A cable Set up your environment Buzz scripts are built and flashed alongside the rest of the HiveMind firmware. You will therefore need to set up your environment to flash the firmware to the board before writing your first Buzz script. Follow the instructions in HiveMind's README file to set up the toolchain. Start by connecting the HiveBoard to your computer using a micro-USB cable. Next, plug in the power supply using the wall adapter. Turn on the power by setting the power swith to CON . You should see the HiveBoard light up. If the HiveBoard already has a firmware, it should output its logs via a COM port (usually ttyUSB2 ). You might want to check the output using your favorite tool. When you fire up the HiveBoard, you will see some lights flashing. Some of these lights are user-controllable, and some other present the status of the board. Refer to the UI description for a complete list of the available lights and buttons. Next, let's flash the HiveMind firmware to the HiveBoard. Follow the steps written in HiveMind's README file to build and flash your board. Follow the steps for the H7/HiveBoard . Important Take a close look to the requirements listed in the README and make sure you use the correct versions of CMake, GCC, arm-gcc, and OpenOCD. In HiveMind's README, you will find some steps to build using ROS. You need not follow these steps for now; the ROS build is only used in simulation. This how-to guide only shows how to compile and flash for the HiveBoard. Once you have successfully flashed the firmware to the board, you may go to the next step, where you will write, compile, and flash a Buzz script. Writing a Buzz Script User-defined Buzz scripts are located within the HiveMind codebase, in folder bittybuzz/buzz_scripts . The Buzz language will not be documented in these guides. Users can refer to the official documentation . The Entrypoint: main.bzz The single entrypoint to the Buzz application is the main.bzz file. Here is an example: # main.bzz include \"blinky.bzz\" function init () { exec = create_exec ( 10 ); } function step () { exec . step (); } The main file is used to select the Buzz script to be run, by including the right file. Usually, the main file is not meant to be very long, as all the applicative logic should be in the included file. In this example, we will create a file called blinky.bzz , which will do some basic interaction with the HiveBoard's I/O, namely flashing some LEDs. As you can see in the code snippet above, the main.bzz file already includes the name of the file we want to create. The main file is written in such way that the user will not need to edit anything but the include tag. It expects the included file to provide a function create_exec() as its entrypoint. This function creates an executor which will call a function at given intervals (more on that below). Here, we pass the value 10 , which means that the function will be called at every 10 steps of the BittyBuzz virtual machine. For more information on how to configure the step delay, refer to this page . Tip This pattern of using a minimal main is not an absolute rule; users could write everything directly in the main.bzz file, instead of using a separate file. This implementation just makes it easier to switch from one buzz script to the other by simply changing the included file in the main. On your PC, create a main.bzz file under bittybuzz/buzz_scripts and copy the snippet shown above. Note Il you cloned the HiveMind repository from GitHub, this step might not be required, since the code hosted on GitHub already contains a main file. The Script: blinky.bzz The next step is to create a new file called blinky.bzz under bittybuzz/buzz_scripts . This file should provide a create_exec() function to be used within main.bzz as an entrypoint. The create_exec() function must return an executor object. An executor is simply an object which will call a function at regular intervals (see executor.bzz ). Let's write the create_exec() function: # blinky.bzz include \"utils/executor.bzz\" ctx = { . led = 0 , } function tick ( context ){ } function create_exec ( step_count ) { exec = executor . new ( step_count , tick , ctx ); return exec ; } Creating an executor requires three arguments. The first argument is the interval at which the function will be called. In the example above, we use the step_count argument, which corresponds to the value 10 passed from main.bzz . Hint You could also use the .new_ms constructor for the executor. In this case, the executor would take an interval in miliseconds, instead of a number of steps (see here ). The second argument is the function to be run by the executor . Here, we provided the function tick , which we also defined above. This function should contain the logic you want to implement. The third argument is a context table that will be passed to the function tick everytime it is run. We use a table instead of plain variables because Buzz always passes tables by reference (and not by value). Therefore, the context can be modified by the tick function and it will be persisted between the executions of tick . The ctx object contains the value of the LED. Tip Why should you use an executor object instead of sleep functions? The executor object serves a similar purpose as a thread with a while(true) and a sleep. However, using sleeps will halt some other processing done on the BittyBuzz virtual machine. The executor allows for asynchronous, non-blocking delays. See the Reference section for more details. Writing the tick() function The tick function will contain all the applicative logic. In this example, we want to flash an LED. Let's first discuss the function we will use to interact with the HiveBoard's hardware. HiveMind provides various APIs that the user can use from within the Buzz scripts. One of these APIs are the BittyBuzzUIFunctions (see the API reference here ). The UI API has functions to control an LED and one of the seven segment display. In the Buzz script, the user can interact with the UI by using the ui global object. To light the LED, simply write: ui . set_led ( 1 ) To turn the LED off, we write the opposite value: ui . set_led ( nil ) Hint You could also write ui.set_let(0) . The underlying function would then evaluate the value 0 to false. All other integer values would be evaluated to true. To toggle on and off the LED, we write the following tick function: # blinky.bzz include \"utils/executor.bzz\" ctx = { . led = 0 } function tick ( context ){ log ( \"Led set to : \" , context . led ); ui . set_led ( context . led ); # led = !led if ( context . led ){ context . led = nil ; } else { context . led = 1 ; } } function create_exec ( step_count ) { exec = executor . new ( step_count , tick , ctx ); return exec ; } Copy this snippet in blinky.bzz . Save the file, and flash the code to the HiveBoard. The HiveBoard will reboot and you should see the MCU2 light blinking. You'll have noticed in the code that the tick function uses a logger. To view the output, use your favorite tool to open the appropriate COM port (usually ttyUSB2 ). You should see the following output: Writing to the seven-segment display User-defined Buzz scripts also have access to a seven-segment display. This display has been configured to write values from 0 to 15 in hexadecimal format. Let's add some Buzz code to show this. Writing an hexadecimal value to the seven-segment works the same way as the LED. Using the global object ui , we just need to pass the value we want as an argument to the function set_hex() : ui . set_hex ( 12 ) Users need only provide the values as integers, and they will be displayed in hexadecimal format. In this case, the value 12 would be displayed as C . Let's add some code to the blinky example that will increment the value of the seven-segment up to 15 and then go back to zero: include \"utils/executor.bzz\" ctx = { . led = 0 , . hex = 0 } function tick ( context ){ log ( \"Led set to : \" , context . led , \" and hex set to :\" , context . hex ); ui . set_led ( context . led ); ui . set_hex ( context . hex ); # led = !led if ( context . led ){ context . led = nil ; } else { context . led = 1 ; } if ( context . hex > 15 ){ context . hex = 0 ; } else { context . hex = context . hex + 1 ; } } function create_exec ( step_count ) { exec = executor . new ( step_count , tick , ctx ); return exec ; } Flash this code to the HiveBoard. You should see the seven-segment display looping from 0 to F and the MCU2 LED should still blink.","title":"Flashing an LED Using Buzz"},{"location":"sections/user-guide/basic-examples/led-flash-buzz/#flahshing-an-led-using-buzz","text":"This page presents the steps to write a first basic Buzz script and load it on a HiveBoard. The script will make an LED flash on the board. Note To follow this user guide, you will need: A computer running Linux One HiveBoard and its power supply (wall adapter) A micro-USB to USB type A cable","title":"Flahshing an LED using Buzz"},{"location":"sections/user-guide/basic-examples/led-flash-buzz/#set-up-your-environment","text":"Buzz scripts are built and flashed alongside the rest of the HiveMind firmware. You will therefore need to set up your environment to flash the firmware to the board before writing your first Buzz script. Follow the instructions in HiveMind's README file to set up the toolchain. Start by connecting the HiveBoard to your computer using a micro-USB cable. Next, plug in the power supply using the wall adapter. Turn on the power by setting the power swith to CON . You should see the HiveBoard light up. If the HiveBoard already has a firmware, it should output its logs via a COM port (usually ttyUSB2 ). You might want to check the output using your favorite tool. When you fire up the HiveBoard, you will see some lights flashing. Some of these lights are user-controllable, and some other present the status of the board. Refer to the UI description for a complete list of the available lights and buttons. Next, let's flash the HiveMind firmware to the HiveBoard. Follow the steps written in HiveMind's README file to build and flash your board. Follow the steps for the H7/HiveBoard . Important Take a close look to the requirements listed in the README and make sure you use the correct versions of CMake, GCC, arm-gcc, and OpenOCD. In HiveMind's README, you will find some steps to build using ROS. You need not follow these steps for now; the ROS build is only used in simulation. This how-to guide only shows how to compile and flash for the HiveBoard. Once you have successfully flashed the firmware to the board, you may go to the next step, where you will write, compile, and flash a Buzz script.","title":"Set up your environment"},{"location":"sections/user-guide/basic-examples/led-flash-buzz/#writing-a-buzz-script","text":"User-defined Buzz scripts are located within the HiveMind codebase, in folder bittybuzz/buzz_scripts . The Buzz language will not be documented in these guides. Users can refer to the official documentation .","title":"Writing a Buzz Script"},{"location":"sections/user-guide/basic-examples/led-flash-buzz/#the-entrypoint-mainbzz","text":"The single entrypoint to the Buzz application is the main.bzz file. Here is an example: # main.bzz include \"blinky.bzz\" function init () { exec = create_exec ( 10 ); } function step () { exec . step (); } The main file is used to select the Buzz script to be run, by including the right file. Usually, the main file is not meant to be very long, as all the applicative logic should be in the included file. In this example, we will create a file called blinky.bzz , which will do some basic interaction with the HiveBoard's I/O, namely flashing some LEDs. As you can see in the code snippet above, the main.bzz file already includes the name of the file we want to create. The main file is written in such way that the user will not need to edit anything but the include tag. It expects the included file to provide a function create_exec() as its entrypoint. This function creates an executor which will call a function at given intervals (more on that below). Here, we pass the value 10 , which means that the function will be called at every 10 steps of the BittyBuzz virtual machine. For more information on how to configure the step delay, refer to this page . Tip This pattern of using a minimal main is not an absolute rule; users could write everything directly in the main.bzz file, instead of using a separate file. This implementation just makes it easier to switch from one buzz script to the other by simply changing the included file in the main. On your PC, create a main.bzz file under bittybuzz/buzz_scripts and copy the snippet shown above. Note Il you cloned the HiveMind repository from GitHub, this step might not be required, since the code hosted on GitHub already contains a main file.","title":"The Entrypoint: main.bzz"},{"location":"sections/user-guide/basic-examples/led-flash-buzz/#the-script-blinkybzz","text":"The next step is to create a new file called blinky.bzz under bittybuzz/buzz_scripts . This file should provide a create_exec() function to be used within main.bzz as an entrypoint. The create_exec() function must return an executor object. An executor is simply an object which will call a function at regular intervals (see executor.bzz ). Let's write the create_exec() function: # blinky.bzz include \"utils/executor.bzz\" ctx = { . led = 0 , } function tick ( context ){ } function create_exec ( step_count ) { exec = executor . new ( step_count , tick , ctx ); return exec ; } Creating an executor requires three arguments. The first argument is the interval at which the function will be called. In the example above, we use the step_count argument, which corresponds to the value 10 passed from main.bzz . Hint You could also use the .new_ms constructor for the executor. In this case, the executor would take an interval in miliseconds, instead of a number of steps (see here ). The second argument is the function to be run by the executor . Here, we provided the function tick , which we also defined above. This function should contain the logic you want to implement. The third argument is a context table that will be passed to the function tick everytime it is run. We use a table instead of plain variables because Buzz always passes tables by reference (and not by value). Therefore, the context can be modified by the tick function and it will be persisted between the executions of tick . The ctx object contains the value of the LED. Tip Why should you use an executor object instead of sleep functions? The executor object serves a similar purpose as a thread with a while(true) and a sleep. However, using sleeps will halt some other processing done on the BittyBuzz virtual machine. The executor allows for asynchronous, non-blocking delays. See the Reference section for more details.","title":"The Script: blinky.bzz"},{"location":"sections/user-guide/basic-examples/led-flash-buzz/#writing-the-tick-function","text":"The tick function will contain all the applicative logic. In this example, we want to flash an LED. Let's first discuss the function we will use to interact with the HiveBoard's hardware. HiveMind provides various APIs that the user can use from within the Buzz scripts. One of these APIs are the BittyBuzzUIFunctions (see the API reference here ). The UI API has functions to control an LED and one of the seven segment display. In the Buzz script, the user can interact with the UI by using the ui global object. To light the LED, simply write: ui . set_led ( 1 ) To turn the LED off, we write the opposite value: ui . set_led ( nil ) Hint You could also write ui.set_let(0) . The underlying function would then evaluate the value 0 to false. All other integer values would be evaluated to true. To toggle on and off the LED, we write the following tick function: # blinky.bzz include \"utils/executor.bzz\" ctx = { . led = 0 } function tick ( context ){ log ( \"Led set to : \" , context . led ); ui . set_led ( context . led ); # led = !led if ( context . led ){ context . led = nil ; } else { context . led = 1 ; } } function create_exec ( step_count ) { exec = executor . new ( step_count , tick , ctx ); return exec ; } Copy this snippet in blinky.bzz . Save the file, and flash the code to the HiveBoard. The HiveBoard will reboot and you should see the MCU2 light blinking. You'll have noticed in the code that the tick function uses a logger. To view the output, use your favorite tool to open the appropriate COM port (usually ttyUSB2 ). You should see the following output:","title":"Writing the tick() function"},{"location":"sections/user-guide/basic-examples/led-flash-buzz/#writing-to-the-seven-segment-display","text":"User-defined Buzz scripts also have access to a seven-segment display. This display has been configured to write values from 0 to 15 in hexadecimal format. Let's add some Buzz code to show this. Writing an hexadecimal value to the seven-segment works the same way as the LED. Using the global object ui , we just need to pass the value we want as an argument to the function set_hex() : ui . set_hex ( 12 ) Users need only provide the values as integers, and they will be displayed in hexadecimal format. In this case, the value 12 would be displayed as C . Let's add some code to the blinky example that will increment the value of the seven-segment up to 15 and then go back to zero: include \"utils/executor.bzz\" ctx = { . led = 0 , . hex = 0 } function tick ( context ){ log ( \"Led set to : \" , context . led , \" and hex set to :\" , context . hex ); ui . set_led ( context . led ); ui . set_hex ( context . hex ); # led = !led if ( context . led ){ context . led = nil ; } else { context . led = 1 ; } if ( context . hex > 15 ){ context . hex = 0 ; } else { context . hex = context . hex + 1 ; } } function create_exec ( step_count ) { exec = executor . new ( step_count , tick , ctx ); return exec ; } Flash this code to the HiveBoard. You should see the seven-segment display looping from 0 to F and the MCU2 LED should still blink.","title":"Writing to the seven-segment display"},{"location":"sections/user-guide/basic-examples/led-flash-remote-hiveboard/","text":"Flasing an LED on a remote Hiveboard Now that a LED is flashing on a local Hiveboard , let us use Buzz to interact between two HiveBoards. The goal here is to create a swarm of two agents using two HiveBoards. The first HiveBoard will send a command to the second, asking it to display some information using its LEDs. This will help you familiarize with the networking capabilities of the SwarmUS platform and show some more features of the software stack. Note To follow this user guide, you will need: A computer running Linux Two HiveBoards and their power supply (wall adapter). The HiveBoards must have their ESP32 chip flashed with the latest HiveConnect firmware. A Wi-Fi antenna for each HiveBoard A micro-USB to USB type A cable (to plug the HiveBoards to the computer) An Android device running HiveAR (to setup the Wi-Fi network) A micro-USB to USB type C cable (to plug the HiveBoards to the Android device; any series of adapters will do) Prerequesites Before you go on with this tutorial, make sure that you have set up you environment and that you can flash a HiveMind firmware to your HiveBoards. Refer to the previous User Guide for the procedure. This User Guide will make use of the Wi-Fi networking capabilities of the SwarmUS platform. You will need to set up a Wi-Fi network between your two HiveBoards. Follow this procedure from the Reference section to set up the Wi-Fi network. You can use any network topology, as long as both HiveBoards are on the same Wi-Fi network . Writing an Enhanced blinky.bzz Let's say that the two HiveBoards we use have IDs 2 and 5. We will write a single Buzz script which will set a \"leader\" using the virtual stigmergy (a most important feature from the Buzz language ) to set HiveBoard #2 as the leader. The leader will increment its own 7-segment display and then \"ask\" the HiveBoard #5 to do the same using a function call. Note You might want to double check that the two HiveBoards have their IDs set to 2 and 5. The UUID_OVERRIDE CMake flag in HiveMind is used to set the ID of a board. See HiveMind's README for more on this. Hint The virtual stigmergy is an array of information which is propagated across the swarm agents. It can be used to synchronize the behaviour of each angent. In this example, it is simply used to decide which HiveBoard is the leader. There are many ways to exchange information between HiveBoards. Here we present two: the virtual stigmergy, and the use of function calls, where HiveBoard #2 will call a function on HiveBoard #5. Create a new file called blinky_swarm.bzz and copy the following script. This code is meant to be run identically on both HiveBoards . Notice how this script looks a lot like the one from the previous User Guide , apart from a few additions. Attention Do not forget to include the new blinky_swarm.bzz file at the top of main.bzz so that it can be built. include \"utils/executor.bzz\" ctx = { . hex = 0 } function tick ( context ){ var leader = stig . get ( \"leader\" ); if ( leader == id ){ call_buzz_function ( 5 , \"blinky_set_hex\" , { .0 = context . hex }); ui . set_hex ( context . hex ); if ( context . hex >= 15 ){ context . hex = 0 ; } else { context . hex = context . hex + 1 ; } } } function blinky_set_hex ( arg_int ) { ui . set_hex ( arg_int ); } var args_description = { .0 = {. arg_int = 0 } } function create_exec ( delay ) { stig = stigmergy . create ( 1 ); stig . put ( \"leader\" , 2 ); register_closure ( \"blinky_set_hex\" , blinky_set_hex , args_description , nil ) exec = executor . new_ms ( delay , tick , ctx ); return exec ; } Creating a New Virtual Stigmergy In function create_exec() , we start by creating a new virtual stigmergy. Note The virtual stigmergy is a feature from Buzz itself and will therefore not be extensively documented here. You might want to refer to the Buzz documentation for more on the matter. For our use-case, we use the stigmergy to set the leader. We choose the HiveBoard #2: stig = stigmergy . create ( 1 ); stig . put ( \"leader\" , 2 ); Notice in the tick() function how the value for the leader is accessed at every loop. This ensures that if the leader changes, the behaviour will adapt: var leader = stig . get ( \"leader\" ); Registering a Closure In our use-case, we want the leader to increment the value shown on the 7-segment display of HiveBoard #5. To do that, we expose a closure to the swarm, called blinky_set_hex . The leader will then call this custom function to set the value. We start by defining the function: function blinky_set_hex ( arg_int ) { ui . set_hex ( arg_int ); } var args_description = { .0 = {. arg_int = 0 } } Then, in the create_exec() function, we register the closure: register_closure ( \"blinky_set_hex\" , blinky_set_hex , args_description , nil ) Hint The reference documentation for the registration of closures, as well as everything involving user callbacks is linked here . Calling a Remote Closure In the function tick() , notice how the execution of the incrementation code is conditional. The if (leader == id) statement verifies whether or not the agent running this code is the leader, based on the value retreived from the virtual stigmergy. When this code is run by the leader, it increments the 7-segment value and calls the function blinky_set_hex on the agent #5 with the hex value passed as argument. The reference documentation for the calling of closures, as well as everything involving user callbacks is linked here . Flash and Test You can now flash the code to the two HiveBoards. Make sure that the Wi-Fi network is correctly set up and that both HiveBoards are connected to the same SSID (refer to the instructions here ). When both HiveBoards are flashed with the code, you should see the 7-segment display incrementing on both HiveBoards. More examples Controlling Multiple Slaves An alternate version of the script presented earlier can be found here in the HiveMind repository. This script uses some other features from Buzz, namely the broadcast and listen functions, which allow to communicate in a pub/sub manner using topics (see Buzz documentation for more on the matter). This allows for multiple agents to be controlled by the Leader, without the need to make a function call for each agent. Synchronizing LEDs Without a Leader One of the most interesting advantage of swarm robotics is the ability of a swarm to self-govern, without the need for a centralized manager. As such, the HiveMind repository provides an example script where each agent will synchronize its LEDs with the rest of the swarm, just like fireflies do.","title":"Flashing an LED on a remote Hiveboard"},{"location":"sections/user-guide/basic-examples/led-flash-remote-hiveboard/#flasing-an-led-on-a-remote-hiveboard","text":"Now that a LED is flashing on a local Hiveboard , let us use Buzz to interact between two HiveBoards. The goal here is to create a swarm of two agents using two HiveBoards. The first HiveBoard will send a command to the second, asking it to display some information using its LEDs. This will help you familiarize with the networking capabilities of the SwarmUS platform and show some more features of the software stack. Note To follow this user guide, you will need: A computer running Linux Two HiveBoards and their power supply (wall adapter). The HiveBoards must have their ESP32 chip flashed with the latest HiveConnect firmware. A Wi-Fi antenna for each HiveBoard A micro-USB to USB type A cable (to plug the HiveBoards to the computer) An Android device running HiveAR (to setup the Wi-Fi network) A micro-USB to USB type C cable (to plug the HiveBoards to the Android device; any series of adapters will do)","title":"Flasing an LED on a remote Hiveboard"},{"location":"sections/user-guide/basic-examples/led-flash-remote-hiveboard/#prerequesites","text":"Before you go on with this tutorial, make sure that you have set up you environment and that you can flash a HiveMind firmware to your HiveBoards. Refer to the previous User Guide for the procedure. This User Guide will make use of the Wi-Fi networking capabilities of the SwarmUS platform. You will need to set up a Wi-Fi network between your two HiveBoards. Follow this procedure from the Reference section to set up the Wi-Fi network. You can use any network topology, as long as both HiveBoards are on the same Wi-Fi network .","title":"Prerequesites"},{"location":"sections/user-guide/basic-examples/led-flash-remote-hiveboard/#writing-an-enhanced-blinkybzz","text":"Let's say that the two HiveBoards we use have IDs 2 and 5. We will write a single Buzz script which will set a \"leader\" using the virtual stigmergy (a most important feature from the Buzz language ) to set HiveBoard #2 as the leader. The leader will increment its own 7-segment display and then \"ask\" the HiveBoard #5 to do the same using a function call. Note You might want to double check that the two HiveBoards have their IDs set to 2 and 5. The UUID_OVERRIDE CMake flag in HiveMind is used to set the ID of a board. See HiveMind's README for more on this. Hint The virtual stigmergy is an array of information which is propagated across the swarm agents. It can be used to synchronize the behaviour of each angent. In this example, it is simply used to decide which HiveBoard is the leader. There are many ways to exchange information between HiveBoards. Here we present two: the virtual stigmergy, and the use of function calls, where HiveBoard #2 will call a function on HiveBoard #5. Create a new file called blinky_swarm.bzz and copy the following script. This code is meant to be run identically on both HiveBoards . Notice how this script looks a lot like the one from the previous User Guide , apart from a few additions. Attention Do not forget to include the new blinky_swarm.bzz file at the top of main.bzz so that it can be built. include \"utils/executor.bzz\" ctx = { . hex = 0 } function tick ( context ){ var leader = stig . get ( \"leader\" ); if ( leader == id ){ call_buzz_function ( 5 , \"blinky_set_hex\" , { .0 = context . hex }); ui . set_hex ( context . hex ); if ( context . hex >= 15 ){ context . hex = 0 ; } else { context . hex = context . hex + 1 ; } } } function blinky_set_hex ( arg_int ) { ui . set_hex ( arg_int ); } var args_description = { .0 = {. arg_int = 0 } } function create_exec ( delay ) { stig = stigmergy . create ( 1 ); stig . put ( \"leader\" , 2 ); register_closure ( \"blinky_set_hex\" , blinky_set_hex , args_description , nil ) exec = executor . new_ms ( delay , tick , ctx ); return exec ; }","title":"Writing an Enhanced blinky.bzz"},{"location":"sections/user-guide/basic-examples/led-flash-remote-hiveboard/#creating-a-new-virtual-stigmergy","text":"In function create_exec() , we start by creating a new virtual stigmergy. Note The virtual stigmergy is a feature from Buzz itself and will therefore not be extensively documented here. You might want to refer to the Buzz documentation for more on the matter. For our use-case, we use the stigmergy to set the leader. We choose the HiveBoard #2: stig = stigmergy . create ( 1 ); stig . put ( \"leader\" , 2 ); Notice in the tick() function how the value for the leader is accessed at every loop. This ensures that if the leader changes, the behaviour will adapt: var leader = stig . get ( \"leader\" );","title":"Creating a New Virtual Stigmergy"},{"location":"sections/user-guide/basic-examples/led-flash-remote-hiveboard/#registering-a-closure","text":"In our use-case, we want the leader to increment the value shown on the 7-segment display of HiveBoard #5. To do that, we expose a closure to the swarm, called blinky_set_hex . The leader will then call this custom function to set the value. We start by defining the function: function blinky_set_hex ( arg_int ) { ui . set_hex ( arg_int ); } var args_description = { .0 = {. arg_int = 0 } } Then, in the create_exec() function, we register the closure: register_closure ( \"blinky_set_hex\" , blinky_set_hex , args_description , nil ) Hint The reference documentation for the registration of closures, as well as everything involving user callbacks is linked here .","title":"Registering a Closure"},{"location":"sections/user-guide/basic-examples/led-flash-remote-hiveboard/#calling-a-remote-closure","text":"In the function tick() , notice how the execution of the incrementation code is conditional. The if (leader == id) statement verifies whether or not the agent running this code is the leader, based on the value retreived from the virtual stigmergy. When this code is run by the leader, it increments the 7-segment value and calls the function blinky_set_hex on the agent #5 with the hex value passed as argument. The reference documentation for the calling of closures, as well as everything involving user callbacks is linked here .","title":"Calling a Remote Closure"},{"location":"sections/user-guide/basic-examples/led-flash-remote-hiveboard/#flash-and-test","text":"You can now flash the code to the two HiveBoards. Make sure that the Wi-Fi network is correctly set up and that both HiveBoards are connected to the same SSID (refer to the instructions here ). When both HiveBoards are flashed with the code, you should see the 7-segment display incrementing on both HiveBoards.","title":"Flash and Test"},{"location":"sections/user-guide/basic-examples/led-flash-remote-hiveboard/#more-examples","text":"","title":"More examples"},{"location":"sections/user-guide/basic-examples/led-flash-remote-hiveboard/#controlling-multiple-slaves","text":"An alternate version of the script presented earlier can be found here in the HiveMind repository. This script uses some other features from Buzz, namely the broadcast and listen functions, which allow to communicate in a pub/sub manner using topics (see Buzz documentation for more on the matter). This allows for multiple agents to be controlled by the Leader, without the need to make a function call for each agent.","title":"Controlling Multiple Slaves"},{"location":"sections/user-guide/basic-examples/led-flash-remote-hiveboard/#synchronizing-leds-without-a-leader","text":"One of the most interesting advantage of swarm robotics is the ability of a swarm to self-govern, without the need for a centralized manager. As such, the HiveMind repository provides an example script where each agent will synchronize its LEDs with the rest of the swarm, just like fireflies do.","title":"Synchronizing LEDs Without a Leader"}]}